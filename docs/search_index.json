[
["index.html", "Introduction to Programming with R Prerequisites", " Introduction to Programming with R Reto Stauffer, Thorsten Simon 2019-09-08 Prerequisites This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). The bookdown package can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],
["preface.html", "Preface", " Preface This is the preface. Create the following matrix: ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 Well, that’s simple! We just have to do this: x &lt;- matrix(1:12, ncol = 3) x ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 "],
["introduction.html", "Chapter 1 Introduction 1.1 Programming 1.2 Why not Natural Languages? 1.3 History of Programming 1.4 Number of Languages 1.5 The R Programming Language 1.6 The R Ecosystem 1.7 Examples", " Chapter 1 Introduction 1.1 Programming Programming is the way of telling a computer how to do certain things by giving it (unambiguous) instructions. The person who writes these instructions (you) is called a programmer, the instructions itself are called a program. Instructions can be written in many different ways, depending on the task which has to be done. The format in which instructions are written are called programming languages. Why should I learn to code? Nowadays, tech is everywhere: laptops, smart phones, the display panel at the bus stop, the automatic doors at this university, and even in your coffee machine. Learning to code improves your problem-solving and logical skills and teaches you how to efficiently solve a specific problem. You’ll quickly see that there is a solution for everything and being able to write small or large programs will make things (much!) easier. Spending less time on solving a complex and/or repetitive problem gives you more time to learn new things, think outside the box, and to think of new and interesting (research) questions. Furthermore, being able to code will also increase your chances on the job market. Understanding what programs can do and how they can be deployed is more and more required in companies of all sizes and sectors. Even if you might not be employed as a full-time programmer having a programming background helps you to improve communication, e.g., between you and your colleagues, customers, or team mates. And, last but not least, programming is so much fun! Writing programs can be extremely creative, if one allows it to be. 1.2 Why not Natural Languages? Natural languages, such as German or English, are ambiguous (the same sentence/words in different situations may have different meanings), are fuzzily structured (we all know that there are always exceptions to the basic grammar rules), and have large (changing) vocabularies. For a computer, understanding natural languages is extremely difficult. Examples: I got struck by a bolt. (A bolt can be a small piece of metal, or a lightning. One hurts, the other one is quite likely life threatening) Ich sollte den Baum umfahren. (In German umfahren can be “drive around the obstacle” or “run it down”/“run over it”) Thus different explicit languages have been developed for different tasks. Mathematicians designed a very strict mathematical notation (e.g., 10 + 1 = 11, 100/5000 = 0.2). Another example are chemists who use a very strict notation for chemical equations (e.g., \\(CH_4 + 2\\,O_2 \\rightarrow CO_2 + 2\\,H_2O\\)). Very similar, computer scientists had to define a language which allows them to give a machine some instructions such that it does what it should do. This is we call a programming language. As computers are “stupid” (they have no common sense) programming languages have to have relatively few and exactly defined rules and strictly controlled vocabularies. Every word (can be a variable name, a function, or a command) has to be defined before it can be used and can only be defined once (at a time). 1.3 History of Programming Modern programming goes back to the first part of the last century. The Z1, developed by Konradu Zuse (Germany) is known as the first modern programmable binary calculator. The Z1 was still a mechanical machine and, unfortunately, very complex and unreliable. Modern electronic computers were developed during/after the second world war. Back in these early years programs were often stored on so called punched cards (pieces of cardboard/paper with holes). The first high-level programming language was Fortran developed back in 1954 - and still in use. Some more facts: 1938: Z1 by Konrad Zuse (GER) 1945: first operational modern computer (U.S.) 1950: first computer where the program was stored in memory 1954: first high-level programming language (Fortran) 1974: Xerox Alto, first workstation 1976: IBM 5100, first laptop (weight: 25 kg; display size: 5’’) 2000+: first smart phones Since then (starting with Fortran in 1954) a wide range of programming languages have become available. An up-to-date list of programming languages can be found here. 1.4 Number of Languages Today, 7111 different living natural languages are known (recognized by ISO~639) and 8945 programming languages (including different versions of the same software; see hopl.info). If programming languages are explicit and well defined, why do we need so many different ones? Well, depending on the task different languages have different advantages and drawbacks. Different programming languages have been designed for different tasks, devices, and/or requirements. Some are designed to run on different operating systems, others for web applications or for highly efficient parallel computing. A “one for all” programming language does not exist and will quite likely never exist in the future. For those interested: “Hello world” in 250 languages “99 bottles of beer” in 1500 languages “Rosetta Code” in over 700 languages 1.5 The R Programming Language 1.5.1 What is R? For short: R is a dialect of S! To be more specific: R is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing. And, of course, R also has its own history. The software we use today originates from S developed by John Chambers back in 1976 and was originally written to make his own life easier (Bell Labs, a toolbox for internal data analysis). The software originally written as a set of Fortran libraries but has been rewritten in C back in 1988. Ten years later, 1998, version 4 of S has been released, but then S got sold to a private company (and further developed to S-PLUS). As S was no longer available for public use Ross Ihaka and Robert Gentleman (Department of Statistics at the University of Auckland) started to develop R back in 1991 based on S version 4 (the last free open source version). Officially, R got announced in 1993 (26 years ago). The current version (version 3.5.2) has been released just before Christmas last year, the next minor update should become available these days. S was invented by John Chambers 1976 (`Fortran) S rewritten in C in 1988 S version 4 released in 1998 (the one we use today) S got sold (further developed to S-PLUS) R developed in 1991 by Ross Ihaka and Robert Gentleman R first official release in 1993 Current release candidate: R version 3.5.2 Why is it important to know the history of R? Well, first of all because a lot of people will ask you why R is called R (for sure). And secondly because it is important to keep in mind that R (also S and S-PLUS) is written from statisticians for statisticians. This is the biggest advantage of R, and at the same time also one of the biggest disadvantages :). An important aspect of R is that R is free! It’s free as in free speech, not as in free beer and released under the GNU Public License which guarantees four essential freedoms: Freedom 0: The freedom to run the program as you wish, for any purpose. Freedom 1: The freedom to study how the program works, and change it so it does your computing as you wish. Access to the source code is a precondition for this. Freedom 2: The freedom to redistribute copies so you can help others. Freedom 3: The freedom to distribute copies of your modified versions to others. By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. 1.5.2 Open Science Open source languages are an important part of good open science practice and help to make research transparent and reproducible. The backbone of good open science: open data open source software/code open methodology open peer review open access publications Furthermore, open source software (open science in general) allows to learn and benefit from others, improve existing methods, and help each other. 1.5.3 R on the job market R is one of the leading programming languages for data science on the job market. The figure below shows the frequency which which different programming languages have been mentioned in job announcements for open data science positions (source: fossbytes.com). 1.6 The R Ecosystem As other programming languages (perl, python, …) the R system is modular. The base installation only provides a ‘small’ set of features (base/recommended packages) but can easily be extended by installing additional packages. Contributed packages (main sources) are available via the Comprehensive R Archive Network (CRAN), however, other sources exist such as Bioconductor (focus on bioinformatics), private and community projects on github, or private packages. Packages exist for nearly everything and different packages may provide similar features, however, not all packages do have the same quality or are carefully maintained. Thus, it is recommended to use packages published via CRAN (or bioconductor) as they undergo some quality control and automated checks while some private packages (e.g., from github) may not work on all operating systems or R versions. One important aspect of all programming languages is to communicate with the outside world to import and export data (see also R Data Import/Export manual) or to communicate over a network. R comes with a custom binary file format. These binary files are typically called .rda/.rds (.Rda/.Rds) and are used to store/load R objects. Beside its own format R allows to read and write data from and to (nearly) all available file formats. R base provides some high-level functions to easily import data from human readable files (e.g., csv or ASCII in general) which is often used for simple data sets. However, there is basically no limit to read and write data in R and packages exist for nearly all file formats, e.g., XLS/XLSX, XML, JSON, NetCDF, rastered data sets such as geotiff, images in general (png/jpg/gif), databases (sqlite/SQL) and many many more. If no package exists, feel free to develop one yourself and contribute it to the R community! R also provides socket connections for server-to-server connections over the network. 1.7 Examples Now as we know what R is, what can we do with it? Well, basically everything you can think of! Your own creativity is the limit - and your programming skills. In this course we will start with basic programming in R to get used to the language, data types and objects, and main control features and functions. The more complex the task, the more complex the program, but the fundamentals wont change. Thus it is very important to acquire solid knowledge of the basics before proceeding to more complex tasks. Below you can see some motivational examples of what you can do with R: 1.7.1 Empirical Mean and Quartiles A simple example of a program (one function) to calculate the empirical mean and the 1th and 3th empirical quartile of a set of 1000 random numbers of a standard uniform distribution (random values between 0 and 1). Side note: As the distribution is symmetric, the mean is asymptotically identical to the median (or the 2th quartile). by theory the thee quartiles should be 0.25, 0.50, and 0.75. let’s try and draw 1000 random numbers, store them on variable x. x will thus get a numeric vector of length 1000 x &lt;- runif(1000) Step two is to create a function which does the job for us. We are creating a function called fun which takes one input argument x and calculates the empirical mean (m), the 1th quartile (q1) and the 3th quartile (q3). At the end a numeric vector of length 3 will be returned containing all three values (c(q1, m, q3)), rounded to three digits. Once our function fun is defined we can call it using our random numbers as input (fun(x)) to get the result. Et voila. fun &lt;- function(x, round = 3) { m &lt;- 1 / length(x) * sum(x) q1 &lt;- sort(x)[round(length(x)*.25)] q3 &lt;- sort(x)[round(length(x)*.75)] return(round(c(q1, m, q3), round)) } # Call the function fun(x) ## [1] 0.239 0.479 0.725 We can, of course, use this function over and over again. Let’s draw another 1000 values from the uniform distribution and call the function again (fun(runif(1000))): fun(runif(1000)) ## [1] 0.263 0.505 0.745 Of course there are implementations for this. One could e.g., use the summary() method or the quantile() function. let’s have a look if our function works as intended: # Repeat again, compare to R&#39;s summary function x &lt;- runif(1000) fun(x, round = 7) ## [1] 0.2423060 0.4962755 0.7478604 c(quantile(x, probs = 0.25, type = 3), mean(x), quantile(x, probs = 0.75, type = 3)) ## 25% 75% ## 0.2423060 0.4962755 0.7478604 # Summary method (uses different quantile approximation function) summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0001154 0.2435042 0.5102453 0.4962755 0.7482093 0.9991448 Note: as random data are used you will never get the same results. 1.7.2 Statistical Modeling One of the biggest strengths of R is, of course the wide range of functions and methods for data analysis and statistical modeling from simple linear regression models to complex and highly nonlinear frameworks. This is just a very small example how easy it can be to do some data analysis. We are using a data set which is contained in datasets package (comes with R base) called ToothGrowth (see ?ToothGrowth for details). The data set contains observations of the length of a special cell which is responsible for the growth of the teeth. The longer (length) the cells, the stronger the teeth are growing (they grow for the entire life). The experiment investigates the impact of vitamin C on these cells. One group got orange juice (OJ), the other one ascorbic acid (a form of vitamin C; VC). Each individuum got either 0.5, 1.0, or 2.0 mg/day. Variables: len: numeric, length of the tooth (cells) supp: factor, supplement type (VC or OJ) dose: the dose in milligrams per day This is how the data set (data.frame) looks like: head(ToothGrowth, 3) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 require(graphics) coplot(len ~ dose | supp, data = ToothGrowth, panel = panel.smooth, xlab = &quot;length vs dose, given type&quot;) And this is the corresponding plot (one way of visualizing this data set). The two supp groups are plotted separately with the orange juice group on the left hand side and the ascorbic acid group on the right hand side. Estimate a linear model on the ToothGrowth data set. Length (len) of the cells responsible for tooth growth conditional on the treatment (supp) and the dose (dose) Rather than only doing a graphical analysis we can also estimate a statistical model. In this case a linear model with might not be the best model (just for illustration) to estimate the overall effect of the two treatments and the effect of increasing the dose (conditional on the treatment). Interpretation of such models is part of statistical bachelor courses and will not be part of this programming course! # Estimate the model: mod &lt;- lm(len ~ supp/dose, data = ToothGrowth) # Coefficient test statistics: lmtest::coeftest(mod) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.5500 1.5814 7.3037 1.090e-09 *** ## suppVC -8.2550 2.2364 -3.6912 0.0005073 *** ## suppOJ:dose 7.8114 1.1954 6.5345 2.028e-08 *** ## suppVC:dose 11.7157 1.1954 9.8005 9.442e-14 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 1.7.3 Spatial Data R is also capable of plotting geo-referenced data sets, e.g., spatial data as in this example. This figure shows the surface air temperature in degrees Celsius for March 7, 2018 at 12 UTC (which is 1 pm local time) based on the ECMWF ERA-5 reanalysis data set using Copernicus Climate Change Service information. R packages used: ecmwfr, ncdf4, raster, maps, colorspace. Some more (mostly) nice spatial R examples can be found on Spatial.ly. 1.7.4 Geographical Data Another common type of visualizations are geo-referenced data on an e.g., national or international level. The figure below is based on a public data set by the National Center for Health Statistics (id bi63-dtpu, csv format) and shows the mean increase in the number of suicides on a state level (excluding Alaska and Hawaii) over the years 1999-2016 in percent. The barplot on the right hand side shows the very same information as the spatial plot on the right hand side. State boundaries downloaded form the GADM website which provides national/political boundaries in an R format (rds) for different levels of detail (national and sub-national). R packages used: sp, zoo, colorspace. For a list of contributed R packages dealing with spatial and spatio-temporal data visit the Spatial and SpatioTemporal CRAN task views. Some more (mostly) nice spatial R examples can be found on Spatial.ly. ### Text Mining Beside spatial or geographical data sets R is also often used for text mining applications (automatically classifying texts, find similarities between different texts, study the evolution of language, …). The example below shows so called word clouds based on the latest 500 tweets (from twitter) from two American politicians. The tweets are downloaded and cleaned (common words as “the” or “A” are removed, URL’s and some special characters or quotes are removed) before counting the frequency of each word. Words which are used more frequent are shown with a larger font size and darker color. Guess who is who? R packages used: rtweet, tm, wordcloud, colorspace. The CRAN task view Natural Language Processing shows an overview/list of contributed R packages for processing language/words. For some more inspiration of graphical representations of R based text mining applications visit bnosac.be. Answer: Donald Trump left (easy), Hillary Clinton right (less obvious but remarkably different to the tweets of the president). ### Three Dimensional Plots Three dimensional plots are always a bit more difficult to produce and they often do not make sense (at least not plotting 3D barplots). However, in some cases three dimensional perspective plots can make sense as in this case. The image below shows the area around Innsbruck, a combination of a digital elevation model (ASTER data) and an OpenStreetMap overlay. Takes quite a while to get this result, but looks cool :). R packages used: OpenStreetMap, rayshader, raster, sp, colorspace. More details available on the rayshader website. "],
["installation.html", "Chapter 2 Installation 2.1 Interfaces and Development Environments (IDE) 2.2 Interactive Examples", " Chapter 2 Installation Installation from source is also possible for numerous (and also exotic) platforms. Manual compilation is easy when the required compilers are already ship with the operating system (e.g., Unix/Linux) in the usual configure/make/install steps. Compilers are also available for MS Windows but might require some more installation/configuration. Thus, this is not recommended if not really needed. 2.1 Interfaces and Development Environments (IDE) The basic R installation comes with a command line interface (CLI), possibly enhanced by some limited graphical user interface (GUI) capabilities on Windows and Mac. The CLI is basically all you need, and if you are a command line enthusiast you can basically stop here :). For all others: various so called integrated development environments (IDEs) exist (e.g., R commander, RStudio, and others). IDEs typically provide interactive command line access (CLI), but also an editor where we will develop code and additional features (such as package and source file management, access to help pages, …). One popular IDE for R is RStudio. RStudio is free to use and open source (but developed and maintained by a private company) and is available for all operating systems (MS Windows, Mac OS X, Linux). To install visit https://www.rstudio.com/products/rstudio/download/ and download the free RStudio Desktop version which fits your operating system. For linux users: RStudio is typically also available via package manager (apt, yum, …). Ater installation and starting RStudio you should see the following IDE: The interface consists of an editor (top left), the R command line (bottom left), a summary of your current workspace (might be empty; shows all objects defined in the current R session; top right) and access to plots, help pages, and packages (bottom right). We will use RStudio during this course, however, feel free to use the pure CLI (there are also plugins to text editors such as vim/neovim) if you are more efficient when not using an IDE. 2.2 Interactive Examples For today we will only try out some basic examples to understand the IDE, we will learn all the details about R’s data types, plot and data I/O functions over the next weeks. Don’t worry if you don’t know in detail what’s going on! For these small interactive examples you will only need the R console (bottom left panel of RStudio). You could, of course, write a script and execute it from the script, however, this is not needed. Thus just try to go trough the small exercises below by typing in the commands to the R console. 2.2.1 R as a basic calculator R can be used as an advanced calculator. As a first example let’s find out what 5 to the power of 2 is. It is obviously 25, but let’s try to solve it with R. To do so we create a variable called a and assign the numeric value 5 to it: # Define a new variable `a` and set `a` to 5 a = 5 a &lt;- 5 # preferred way # Show if it worked print(a) ## [1] 5 # A to the power of `2` in different ways a * a ## [1] 25 a**2 ## [1] 25 a^2 ## [1] 25 Let’s assume you don’t only have to compute \\(5^2\\) but for a set or sequence of numbers. A sequence of numbers is a vector. E.g., c(1, 2, 3) is a vector which contains three different numeric values, 1, 2, and 3. Let’s first specify a new variable, I’ve called it b, which should contain a set of numbers between 0 and 10. In R we can use the function seq(...) which returns us a sequence of values between two limits (from … to). # Define a sequence from 0 to 10 b &lt;- seq(from = 0, to = 10) print(b) ## [1] 0 1 2 3 4 5 6 7 8 9 10 We could now take each element to the power of two (let’s say calculate \\(0^2\\), \\(1^2\\), … element by element which, at least by hand, will take quite some time. In R (as in other programming languages) we can also perform this calculation on a vector which solves it element-wise. Thus, b^2 will take each element of b to the power of 2. # b to the power of 2 b^2 ## [1] 0 1 4 9 16 25 36 49 64 81 100 R also provides a wide range of plotting function. We can use plot(...) to visualize how b^2 looks like by doing something as follows: # Plot b versus b^2 plot(b, b^2) lines(b, b^2, lty = 2) # Adding b versus b (linear) lines(b, b, col = &quot;red&quot;) Another important feature of all programming languages is data import and export. I’ve put a small CVS (comma-separated values) file on OLAT which contains the names and the height of some persons. Download the csv file from OLAT and import the data set using the read.csv(...) function (see below). read.csv(...) returns the content of the file (&quot;height.csv&quot;) if it is able to read the file. If the file is not a CSV file, contains strange things, or is just not well formatted, read.csv will quite likely drop an error and stop. In our case the CSV file should be well-formatted and read.csv should return the data set. We directly assign the data set read from the file to a new variable called data. After the import, the data set will be stored on data and we can use it for our further explorative data analysis. data.frames are somehow similar to XLS tables, a matrix-style data type which consists of rows and columns. Variables are stored in columns, in this case the name of the person and the height of the person, very similar to “_column A, column B, …&quot; in Excel. The rows (23 rows in this example) contain the different persons/individuals and are (in this case) numbered from 1 to 23, just like in Excel. In data.frames we can easily access the different columns of the data set using the $ operator. data$name tells R that we would like to have the data/content of the colum,n name from our data set stored on the variable data. The same yields, of course, for data$height. This allows us to easily calculate the mean height of all our individuals by calling mean(data$height). data &lt;- read.csv(&quot;height.csv&quot;) # Reading CSV data set head(data, n = 3) # First three lines of the data set ## name height ## 1 Michael 172 ## 2 James 176 ## 3 John 178 class(data) # &#39;data&#39; is a &#39;data.frame&#39; object. ## [1] &quot;data.frame&quot; mean(data$height) ## [1] 170.5217 Try to use the min and max function to see how large the talles and shortest ones are. Also try to call summary on the whole data.frame/object or on one specific column. Just for having some fun: let’s try to use different plotting methods to visualize the data set. plot(...) to plot the height hist(...) to get a histogram of the height of the individuals barplot(...) to get a barplot. With the names. Hint: you will need something like barplot(..., names.arg = ...). In R you can always get help by calling ?&lt;function&gt;, e.g., ?plot or ?hist. Try to find some help there if something is not working or to find out which options the different functions provide. For example: changing plot style, adding color, add title and labels, and many more. "],
["getting-help.html", "Chapter 3 Getting Help 3.1 Accessing R documentation/help pages 3.2 Package documentation and vignettes 3.3 Websites 3.4 Ask the community", " Chapter 3 Getting Help There are several ways to find help for R commands and functions. E.g.,: “ask google” (not recommended) use Rs built in documentation html version(s) of the R documentation package manuals and vignettes make use of online communities What people typically do nowadays is to “ask google” or similar search engines. However, this is not recommended, at least not if help for specific functions or commands is needed! If you search online, especially if especially if the query is not very precise, you may end up with a broad range of possible solutions of different flavors and quickly end up installing 20 new packages … which might not be needed. 3.1 Accessing R documentation/help pages R comes with built in documentation for all (exported) functions which can easily be accessed trough the console (or the IDE) by calling ?&lt;command&gt; or help(&lt;command&gt;) where &lt;command&gt; is what you are looking for. As an example: we would like to know how the mean function works (arithmetic mean) and what options it offers. ?mean or help(mean): will open the help page for the arithmetic mean ?plot or help(mean): will open the plot help page ?&quot;?&quot; or help(&quot;?&quot;): will open the help page for ‘how to open the help page’ ?&quot;+&quot; or help(&quot;+&quot;): opens the help page for arithmetic operators The advantage of the R documentation help pages: as they are loaded from your computer they fit your version of the installed software or package. The documentation will help in the bottom left corner. Help pages typically consist of: function name the package in which the command is included (mean is included in the base package) title and a brief description what the function does usage: how the function can be used arguments: available arguments details: more details about the function and the options value: the result; what will be returned when calling the function references: where to get some more information, if needed see also: commands/functions which might also be helpful examples: some (smaller) examples how the function can be used The advantage of the built in R documentation: As the documentation comes with your R installation or the package you have installed the documentation fits your version of the software! And it can also be used offline, if needed. Examples: if the documentation contains examples one can easily run these examples by calling the function example(&lt;command&gt;). Try example(mean) or example(plot) to see how it works. If you don’t know the exact command help.search allows to search for help pages containing a specific keyword. For example: help.search(&quot;mean&quot;) will return a list of help pages containing the word ‘mean’ This search can be refined (see ?help.search). E.g., we can search for help pages containing ‘mean’ in the ‘base’ package by calling help.search(&quot;mean&quot;, package = &quot;base&quot;). A similar function is apropos. Instead of a list apropos returns a character vector of functions which contain the keyword in the function name, e.g.,: # Apropos mean apropos(&quot;mean&quot;) ## [1] &quot;.colMeans&quot; &quot;.rowMeans&quot; &quot;colMeans&quot; &quot;kmeans&quot; ## [5] &quot;mean&quot; &quot;mean.Date&quot; &quot;mean.default&quot; &quot;mean.difftime&quot; ## [9] &quot;mean.POSIXct&quot; &quot;mean.POSIXlt&quot; &quot;rowMeans&quot; &quot;weighted.mean&quot; 3.2 Package documentation and vignettes In addition to the built in help pages contributed R packages come with a PDF manual and, often but not necessarily, with so called vignettes. A vignette is an addition document by the authors of a specific software package which provides some introductory material and/or examples how to use the software and are, in contrast to the manuals (technical documentation) more “tutorial like”. This is often helpful when using a new package for a specific task. As an example: the zoo (for time series data in R) comes with a range of useful vignettes (see https://CRAN.R-project.org/package=zoo). The vignette ‘zoo’ (from the zoo package) can be accessed out of the command line (if zoo is intalled!) by calling: vignette(&quot;zoo&quot;, package = &quot;zoo&quot;) Vignettes (and manuals) can also be found on CRAN for contributed packages. A screenshot of the CRAN website for the package zoo, a package for handling regular and irregular time series in R: 3.3 Websites There are some websites providing access the R documentation. However, all they do is to parse the R documentation and present it as a html website. Looks nice, however not really needed (and you do have to take care if you are reading the manual matching the version of the software/package you are using). As an example: R documentation for mean on rdocumentation.org. 3.4 Ask the community If the documentation does not help you, you may consider using one of the online communities like stackoverflow.com, however, do not overuse them! Before asking a question: think about it once more check if someone else has already asked the same question when posting questions: write well-defined questions, provide sufficient information and (in the best case) provide a minimal which allows others to reproduce your problem. A bad example A good example Select a title which already summarizes the question. Be specific when asking the question and try to keep your questions short (and general). If possible provide a reproduceable minimal example such that others can see what’s going wrong. In addition, provide some information about your current installation. The problem might be connected to a specific R version or package. "],
["nuts-and-bolts.html", "Chapter 4 Nuts and Bolts 4.1 Atomic classes 4.2 Input and Output 4.3 Atomic Classes", " Chapter 4 Nuts and Bolts R is an object oriented programming language. In R basically everything is an object. Objects can be: defined variables (e.g., a, b, result), functions (e.g., mean, max, sin), connection handlers, … (as I said, basically everything). Each object in R has a specific class and can have a set of class-specific attributes and generic functions (or methods). 4.1 Atomic classes There are five so called atomic classes. Atomic classes are the most basic classes on which most high-level objects are based on. These are: double: -0.5, 120.9, 5.0 integer: -1, 121, 5 logical: TRUE and FALSE character: &quot;Reto&quot;, &quot;Innsbruck&quot;, &quot;5&quot; complex: -5+11i, 3+2i, 0+4i You can always check the class of an object by calling class: # numeric x &lt;- 1 class(x) ## [1] &quot;numeric&quot; # character y &lt;- &quot;This is just a dummy text&quot; class(y) ## [1] &quot;character&quot; 4.1.1 Know the basics! It is fundamental to understand the basic objects or data types of R (same for other programming languages). More complex objects are based on these basic data types. Once you have understood the basics it makes it much easier to understand objects of increasing complexity. Thus, knowing the basics is essential to get a good programmer. 4.2 Input and Output This is just a very brief repetition from the last session. In R, values are assigned to objects (input) using either = or &lt;-. The latter one is the preferred way in R. As an example: if we want to store the number 5 on a variable called a we will write a &lt;- 5. This is read as “a gets five”, you can think of it as an arrow assigning 5 to a. An assignment always requires a left and a right hand side, just as in mathematics (a = 5). x = 2 x &lt;- 2 # preferred in R Comments in R can be written everywhere using the # character. Everything behind # will be ignored by R (a comment is not a command, but an explanation or note for those reading your code. # Everything behind &#39;#&#39; is ignored (just a comment) # Comments are not executed: y &lt;- 100 x &lt;- 5 # Can also be at the end of the line Keep in mind that code is more often read than written! Well written comments will make it much easier for you to understand what you did and why you did it (believe me, you will forget it) but also for others checking, using or adapting your code. Some people say a good code-to-comment ratio is 60 percent comments, 40 percent code. When typing commands into R console without assigning the value(s) to an object R prints the values (output), also known as implicit printing. Two examples: 50 ## [1] 50 &quot;A useless character string&quot; ## [1] &quot;A useless character string&quot; We can also explicitly call the print function. The result is the very same. Note: implicit printing is only used when you are working on an interactive R console (as in your IDE). When calling R as a batch job you have to do explicit printing. print(50) ## [1] 50 print(&quot;A useless character string&quot;) ## [1] &quot;A useless character string&quot; On an interactive R command line we can also use both, implicit and explicit printing, when we want to print the current values of an object. In this example we store a character string as y and print it to examine ys current content/values: y &lt;- &quot;A useless character string&quot; print(y) ## [1] &quot;A useless character string&quot; 4.3 Atomic Classes 4.3.1 Double One atomic data class are doubles (double precision floating point values). Double is actually not often used in R, objects of type double are simply called numeric and the class of floating point numbers will be numeric. # define a double (numeric) x &lt;- 1.5 x ## [1] 1.5 # another one x &lt;- 10 x ## [1] 10 class(x) ## [1] &quot;numeric&quot; 4.3.2 Integers A second atomic class are integers. Integers can explicitly be defined using the so called L suffix. While 1 will be numeric, 1L will e integer. # define an integer value x &lt;- 10L x ## [1] 10 class(x) ## [1] &quot;integer&quot; This is not important most of the time when you are using R. Except when it is! There are some situations where integers are required! ### Logical values Logicals are rather simple as they can only take up two different values: either TRUE or FALSE. # logical &quot;true&quot; x &lt;- TRUE x ## [1] TRUE # logical &quot;false&quot; x &lt;- FALSE x ## [1] FALSE class(x) ## [1] &quot;logical&quot; 4.3.3 Characters The last atomic class we will is the character class. A character is basically just a text and can be of any length. # define character string x &lt;- &quot;Austria&quot; x ## [1] &quot;Austria&quot; # can be of an arbitrary length x &lt;- &quot;Max Konstantin Mustermann (AT)&quot; x ## [1] &quot;Max Konstantin Mustermann (AT)&quot; class(x) ## [1] &quot;character&quot; 4.3.4 Checking classes We can check if an object is of a specific class in several different ways. One handy way are the is.* commands. is.character(&quot;foo&quot;) will return logical TRUE if &quot;foo&quot; is a character object and FALSE else. Functions for all base objects exist such as: is.double is.integer is.logical is.character … and many more. is.integer(1.5) ## [1] FALSE is.double(1.5) ## [1] TRUE is.logical(FALSE) ## [1] TRUE "],
["vectors.html", "Chapter 5 Vectors 5.1 Create Vectors 5.2 Vectors 5.3 Missing values 5.4 Coercion 5.5 Attributes 5.6 Vector Attributes 5.7 Vector Subsetting 5.8 Relational and Logical Operators 5.9 Practical Session", " Chapter 5 Vectors So far we have always only assigned one element to a variable, e.g., x &lt;- 5. To assign more than only one single element to an object vectors can be used. A vector is basically just a sequence of elements. Note: vectors can only take up elements of the same class! A character vector can only contain characters, a numeric vector only numerics, and so on. We can define vectors in different ways. One option is to create new vectors by calling the vector function. The function takes two input values: the class of the vector we would like to get (&quot;character&quot;, &quot;numeric&quot;, &quot;logical&quot;, &quot;integer&quot;) and an integer which specifies how long the vector should be. In the example below two vectors are created: an numeric or double vector of length 5, and a character vector of length 3. # Numeric vector of length 5 vector(&quot;double&quot;, length = 5) ## [1] 0 0 0 0 0 # Character vector of length 3 vector(&quot;character&quot;, length = 3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; As you can see both vectors are empty. The default value of numeric vectors is 0, the default for character vectors is &quot;&quot; (just an empty character string, a text without any characters in it). More frequently we will use the c function (for combine values or concatenate). c(...) is a function which takes up multiple values separated by a comma. For example: # Numeric vector with # five explicit values c(5, 4, 3, 2, 1) ## [1] 5 4 3 2 1 # Character vector c(&quot;Innsbruck&quot;, &quot;Austria&quot;) ## [1] &quot;Innsbruck&quot; &quot;Austria&quot; The c(5, 4, 3, 2, 1) creates a vector of length 5 containing 5, 4, …, 1 in this order. As all elements we insert are numeric, the resulting vector will be a numeric vector. In the line below two characters (&quot;Innsbruck&quot;, &quot;Austria&quot;) are combined to a vector. Thus, the result will be a character vector of length 2. We could, of course, repeat this example for all atomic classes like including doubles (numeric), logical, character, integer, and complex values: x &lt;- c(0.5, 0.6, 0.7) # double x &lt;- c(TRUE, FALSE, TRUE) # logical x &lt;- c(T, F, T) # logical x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # character x &lt;- c(1L, 2L, 3L, 4L) # integer x &lt;- 15:20 # integer x &lt;- c(1+0i, 2+4i, 5+2i) # complex Warning: The example above shows that you could also use T and F as an abbreviation for TRUE and FALSE. Please don’t do that! T and F are not protected and can be changed. Below we re-define or overwrite T with &quot;bar&quot; and F with &quot;FOO&quot;. Thus, c(T, T, F, T) becomes something completely different. Even more mean: Imagine what happens if I re-define T &lt;- FALSE and F &lt;- TRUE. c(T, T, F, T) ## [1] TRUE TRUE FALSE TRUE T &lt;- &quot;foo&quot; # overwrite T F &lt;- &quot;bar&quot; # overwrite F c(T, T, F, T) ## [1] &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; Thus, please get used to TRUE and FALSE from the beginnign on. T and F is shorter, but you might run into strange problems at some point which can be avoided by just not using these abbreviations. 5.1 Create Vectors We can also create vectors using different functions. Here we will have a closer look to seq/seq.int (sequence) and rep (repeat). Sequences: sequences are a set of numeric or integer values between two well defined points (from and to) with an equidistant spacing. By default the spacing/increment is 1 but can be explicitly specified using the by argument. Repeat: Repeat allows to repeat a number (or a set of number) in different ways. We can repeat one element several times, repeat a vector multiple times, or repeat the elements of a vector multiple times. Some examples for numeric sequences: # Equidistant sequence seq(from = 1.5, to = 2.5, length = 5) ## [1] 1.50 1.75 2.00 2.25 2.50 # Repeat `1` five times rep(1.0, 5) ## [1] 1 1 1 1 1 # Repat `1` and `2`, each twice rep(c(1, 2), each = 2) ## [1] 1 1 2 2 # Repeat `7` three times, `6` once rep(c(7, 6), c(3, 1)) ## [1] 7 7 7 6 For integer sequences, the repeat function can be used as for numeric values (and all others), however, some things are slightly different for integers. To create an integer sequence with an increment of 1 we can call &lt;from&gt;:&lt;to&gt;, e.g., 50:55 creates an integer sequence between 50 and 55 (can also be used to create decreasing sequences). A seq.int function also exists to create integer sequences. seq.int returns an integer sequence if and only if the from argument can be interpreted as integer. For example: seq.int(from = 5, ...) returns an integer sequence, so does seq.int(from = 5.0, ...). However, if from is no integer (e.g., seq.int(from = 5.5, ...), or the interval is no integer (e.g., seq.int(..., by = 0.5) a numeric sequence will be returned and seq.int acts like seq. Some examples: # Integer from 50 to 55 50:55 ## [1] 50 51 52 53 54 55 # Reverse 55:50 ## [1] 55 54 53 52 51 50 # Sequence seq.int(from = 5, to = 12, by = 2) ## [1] 5 7 9 11 # Repeat `1L` five times rep(1L, 5) ## [1] 1 1 1 1 1 # Repeat `TRUE` 5 times rep(TRUE, 5) ## [1] TRUE TRUE TRUE TRUE TRUE # Repeat `TRUE`/`FALSE` twice rep(c(TRUE, FALSE), each = 2) ## [1] TRUE TRUE FALSE FALSE # Repeat 3 x `FALSE`, 1 x `TRUE` rep(c(FALSE, TRUE), c(3, 1)) ## [1] FALSE FALSE FALSE TRUE … and characters. Convenient for characters: R has two objects you can use called LETTERS and letters. LETTERS contains the alphabet (no special characters) in upper case letters (&quot;A&quot;, &quot;B&quot;, …), letters the same in lower case letters (&quot;a&quot;, &quot;b&quot;, …). This can be used if one just wants to have some random character values. # Repeat `&quot;A&quot;` seven times rep(&quot;A&quot;, 7) ## [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; # First 7 letters of the alphabet LETTERS[1:7] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; letters[1:7] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; 5.2 Vectors As mentioned in the first part of this section: vectors can only contain elements of one type! What happens if we try to mix elements of different classes, e.g., a numeric and a character? # Numeric and character = character x &lt;- c(1.7, &quot;A&quot;) class(x) ## [1] &quot;character&quot; x ## [1] &quot;1.7&quot; &quot;A&quot; The class of x is character. Reason: 1.7 can be converted into character, &quot;A&quot; cannot be converted to a numeric value. Thus, R converts the numeric value to character (note that &quot;1.7&quot; is now a character string which contains the ‘word’ &quot;1.7&quot; and not a number anymore). Similar when mixing logical and numeric values. The result is numeric. Note: we could also convert 6.2 to logical, but all numbers not equal to 0 will be converted to TRUE, and 0 will be converted to FALSE. Thus, if we would convert from numeric to integer we would lose much more information as when converting from logical to integer, that’s why R does it this way around. Example: # Logical and numeric = numeric x &lt;- c(TRUE, 6.2) class(x) ## [1] &quot;numeric&quot; x ## [1] 1.0 6.2 Converting values between different data types (atomic classes) is called coercion, in this case implicit coercion as we did not tell R to do so, but to be able to create our object R has to do it. We can, of course, also use explicit coercion. The as.* functions allow us to explicitly convert values between different classes. E.g., as.character(1.42) will convert the numeric value 1.42 into a character. A wide range of different as.* functions exists such as: as.integer as.numeric as.character as.logical as.matrix Let us create a new integer vector between 0 and 4, assign it to x, and convert this integer vector to logical: # let `x` be an integer vector # with elements 0, 1, 2, 3, 4. x &lt;- 0:4 x ## [1] 0 1 2 3 4 # Coerce to character as.character(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; # Coerce to logical as.logical(x) ## [1] FALSE TRUE TRUE TRUE TRUE As mentioned previously: all numeric values 0 will converted to 0, all others (including negative values) to TRUE. Even if we use explicit coercion it is sometimes not possible to convert from one class to another. Characters from the alphabet, such as &quot;a&quot; or &quot;b&quot; cannot be converted. Characters which are basically only characters containing a numeric value (&quot;100&quot;, &quot;135.3&quot;) can be coerced. If R is not able to convert elements, it will return NA (and throw a warning): # let `x` be a character vector x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) x ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; # Coerce to integer as.integer(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA NA # But ... x &lt;- c(&quot;1&quot;, &quot;100&quot;, &quot;a&quot;, &quot;b&quot;, &quot;33&quot;) as.integer(x) ## Warning: NAs introduced by coercion ## [1] 1 100 NA NA 33 5.3 Missing values So far we have not been talking about missing values. R knows two types of missing values: NaN and NA. NaN is “not a number” and results from mathematical operations which are illegal/invalid. One classical example is if we try to divide 0 by 0. NA is Rs “missing value” element. NaN: mathematically not defined (and always of class numeric) NA: missing value, ’s still have classes! NaN is also NA but not vice versa Examples: # 0/0 is invalid x &lt;- 0/0 class(x) ## [1] &quot;numeric&quot; is.nan(x) ## [1] TRUE is.na(x) ## [1] TRUE x &lt;- 0/0 x ## [1] NaN If you just assign NA to an object (x &lt;- NA) the class of x will be numeric by default. However, for demonstration purposes let us convert a missing value into character and integer using the coercion functions: # numeric/logical NA x &lt;- as.numeric(NA) y &lt;- as.logical(NA) x ## [1] NA class(x) ## [1] &quot;numeric&quot; y ## [1] NA class(y) ## [1] &quot;logical&quot; As you can both x and y look identical (both just contain one single NA element), however, x is of class character while y is of class integer. 5.4 Coercion 5.5 Attributes Objects in R can also have attributes. Attributes can be seen as class specific meta information. Vectors have, by default, a length (number of elements in the vector) and can, optionally, have names. Matrices have attributes which specify the dimension of the matrix and (optional) names for the columns and rows. 5.6 Vector Attributes We can get the length of a vector by calling the length function, and all other attributes by calling attributes. # Basic numeric vector x &lt;- c(28, 1.82) x ## [1] 28.00 1.82 length(x) ## [1] 2 attributes(x) ## NULL As you can see the vector above (x &lt;- c(28, 1.82)) has no additional attributes. We can, however, define a vector with names: # A vector with names y &lt;- c(age = 54, size = 1.82) y ## age size ## 54.00 1.82 length(y) ## [1] 2 attributes(y) # See also `names(y)` ## $names ## [1] &quot;age&quot; &quot;size&quot; Note that the names (age and size) are not part of the values stored in the vector. The vector still contains the two numeric values 54 and 1.82, however, we can now use the names to access the data. 5.7 Vector Subsetting Accessing specific elements of a vector (or an object in general) is called subsetting. For vectors this can be done in several ways: by index (position in the vector) based on logical vectors by name (if defined) 5.7.1 Subsetting by indizes We can access elements by simply specifying the index of the element we would like to get. Subsetting can be done using the squared brackets [...] while function calls use round brackets (e.g., mean(...)). We can simply pick the first or fifth element of a vector x by calling x[1] or x[5]. R will return element 1/5 out of x. If we need the first and the fifth we can also ask for x[c(1, 5)]: x &lt;- c(10, 20, 0, 30, 50) x ## [1] 10 20 0 30 50 # Get first and/or fifth element x[1] ## [1] 10 x[5] ## [1] 50 x[c(1, 5)] ## [1] 10 50 We can also do it the other way around: x[-1] gives us all elements of x except the first one. x[-1] ## [1] 20 0 30 50 x[-5] ## [1] 10 20 0 30 x[-c(1, 5)] ## [1] 20 0 30 Using indizes we can also take the first four elements … # First four elements x &lt;- 1:10 x[1:4] ## [1] 1 2 3 4 … or the last four elements of a vector. # Last four elements x[7:10] ## [1] 7 8 9 10 R provides two convenient functions called head and tail to get the first n entries (default is n = 6) and the last n entries which works on most objects (not only vectors!): # First four elements x &lt;- 1:10 head(x, n = 4) ## [1] 1 2 3 4 # Last four elements tail(x, n = 4) ## [1] 7 8 9 10 5.7.2 Subsetting by name If we have a vector with names, here a vector with three elements named age, height, and zipcode we can also access vector elements by name. Instead of using a numeric index (x[1]) we use a character string to specify the element we would like to get returned. Note that this has to be a character string. Thus, we have to call x[&quot;age&quot;] (with quotes). x[age] does not work as R would try to find an object or variable age which does not exist. If two elements are needed we can, again, also use a vector (in this case a character vector) to get both, the &quot;age&quot; and &quot;height&quot;: x &lt;- c(age = 28, height = 1.82, zipcode = 6020) x[&quot;age&quot;] # age (note &quot;&quot;) ## age ## 28 x[&quot;height&quot;] # height (note &quot;&quot;) ## height ## 1.82 x[c(&quot;age&quot;, &quot;height&quot;)] ## age height ## 28.00 1.82 In contrast to index subsetting x[-&quot;age&quot;] does not work. You cannot get “all elements except age” like it worked for index subsetting. 5.7.3 Subsetting by logical vectors An alternatively we can use a logical vector to subset vectors. Remember: logical vectors contain either TRUE or FALSE. In the context of subsetting it can be used to get all elements where the logical vector contains TRUE. An example: x &lt;- c(10, 20, 0, 30, 50) x[c(TRUE, TRUE, FALSE, FALSE, FALSE)] ## [1] 10 20 As you can see we only get the first two elements, as only the first two elements of the logical vector contain TRUEs. This is what happens if we use logical operators to subset a data frame. Let’s assume that we are interested in getting all elements of x which are larger than 25 (x &gt; 25, see ?Comparison for more information): # Find all values x &gt; 25 x &gt; 25 ## [1] FALSE FALSE FALSE TRUE TRUE # Returns logical vector, thus: x[x &gt; 25] ## [1] 30 50 What happens is: x &gt; 25 returns a logical vector of the same length as x (try x &gt; 25 on the console). x[x &gt; 25] is thus called with a logical vector and we will get all values x where x &gt; 25 (where x &gt; 25 == TRUE. In some situations we might not only be interested in getting all values of x which fulfill a specific condition, we may also want to know where these elements are located in the vector x (we will get the index, not the value). This can be done using which. which(...) returns the index of all TRUEs. which(c(FALSE, TRUE)) will thus return 2 as only the second element is TRUE. We can use this to, for example, find the position of all elements x which are 30 (x == 30, see ?Comparison): # Logical vector where x == 30 y &lt;- x == 30 y ## [1] FALSE FALSE FALSE TRUE FALSE # Find index where x == 30 idx &lt;- which(y == TRUE) idx ## [1] 4 # Get elements x[idx] ## [1] 30 Or with some fewer lines of code (more compact): # Same vector x &lt;- c(10, 20, 0, 30, 50) # Get all x == 30 x[x == 30] ## [1] 30 # Opposite x[!x == 30] ## [1] 10 20 0 50 x[x != 30] ## [1] 10 20 0 50 x[x &gt;= 20 &amp; x &lt; 35] ## [1] 20 30 Logical operators can also be used to find, e.g., the position of the maximum within a vector. which(x == max(x)) returns us the index of the element in x which is equal to the maximum of x. Thus x[which(x == max(x))] will be the very same as max(x). There are two functions to get the index of the maximum/minimum element of x called which.min and which.max: # Using which which(x == max(x)) ## [1] 5 # Special functions: which.min(x) ## [1] 3 which.max(x) ## [1] 5 which.min(x) is equivalent to which(x == min(x)) which.max(x) is equivalent to which(x == max(x)) 5.8 Relational and Logical Operators 5.8.1 Rational Operators We have already used some rational operators to check for values larger, smaller, or equal to a number or character. The full list of rational operators (see also ?Comparison and ?Logic): x &lt; y: where x smaller than y x &gt; y: where x larger than y x &lt;= y: where x smaller or equal y x &gt;= y: where x larger or equal y x == y: where x equals y x != y: where x is not equal to y !: negation (NOT; ! x == 20) \\&amp;: logical “and” (x &gt;= 20 \\&amp; x &lt; 35) |: logical “or” (x == 20 | x &gt; 45) xor: logical “exclusive or’’ (xor(x == 20, x == 50)) x \\%in\\% y: where x in y (value matching; character) ! x \\%in\\% y: where x not in y (value matching; character) Note that there is also &amp;&amp;, || and isTRUE but these are no element wise operations, ignore them for now. 5.9 Practical Session For those who want to practice a bit, try to create the following vectors using rep, seq or other methods/ways we have learned this time: Number 1: ## [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 Number 2: ## [1] 11.0 10.5 10.0 9.5 9.0 8.5 8.0 7.5 7.0 Number 3: ## [1] TRUE TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE Number 4: Create a sequence between -5 and 5 with an interval of 0.1. Number 5: Create a sequence between 100 and 150 with a length of 17. "],
["functions-and-mathematical-operators.html", "Chapter 6 Functions and mathematical operators 6.1 Functions 6.2 When should I use functions? 6.3 The structure of functions 6.4 Functions in R 6.5 Calling functions 6.6 Naming functions 6.7 Functions In Real Life 6.8 Declare Functions in R 6.9 The NULL value in R 6.10 Back to functions 6.11 Practical Session 6.12 Function Recap 6.13 Developing Functions 6.14 Advanced: use script files", " Chapter 6 Functions and mathematical operators In this session we will learn how to write (basic) custom functions in R. For some of the examples and the exercises we may need arithmetics and mathematical functions. We have already used some basic arithmetics such as addition (+) or the power function (^) in the previous lessens. A full list can be found on the R documentation ?Arithmetic (or help(Arithmetic)). In addition to that we may use basic mathematical functions such as sine and cosine (sin, cos), the exponential and natural logarithmic function (exp, log), or others. A full list can be found on the help page for ?Math. 6.1 Functions Functions and control structures are what make your code more dynamic. In programming, “functional programming” is a programming paradigm, a style how code is written. Rather than writing so called spaghetti code (one line after another after another …) functions and control structures allow one to build code in blocks. Writing functions and control structures makes the difference between a pure user and a developer. Functional programing helps to keep the code: more structured, more readable, and much easier to maintain or find errors. Control structures are typically not used when using the interactive command line, but are essential parts of of each program and software we use. Functions are sets of instructions which take over specific tasks. One simple example is the function sd which computes the empirical standard deviation of a set of numeric values. Mathematically the standard deviation is defined as: \\(\\text{sd}(x) = \\sqrt{\\frac{1}{N - 1} \\sum_{i=1}^N (x_i - \\bar{x})^2} ~~|~~ i = 1, \\dots, N\\) Let’s assume we have three numeric vectors and we need the standard deviation from all of them. # Define some values x1 &lt;- rnorm(100, 0, 1) x2 &lt;- rnorm(100, 0, 1.5) x3 &lt;- rnorm(100, 0, 5) # Calculate standard deviation once ... sd1 &lt;- sqrt(sum((x1-mean(x1))^2) / (length(x1)-1)) # ... and again, ... sd2 &lt;- sqrt(sum((x2-mean(x2))^2) / (length(x2)-1)) # ... and again ... sd3 &lt;- sqrt(sum((x3-mean(x3))^2) / (length(x3)-1)) print(c(sd1, sd2, sd3)) ## [1] 0.927984 1.592251 5.257788 … even if the equation for the standard deviation is rather simple you can easily see that the code is quickly getting complex and prone to errors! Rather than doing this spaghetti-style-coding we write ourself a function. Well, sd is a mathematical function from R base, but here we will use a simple hand-written sd function (I call it sdfun): # Define the function once: sdfun &lt;- function(x) { return(sqrt(sum((x - mean(x))^2) / (length(x) - 1))) } # Define some values x1 &lt;- rnorm(100, 0, 1) x2 &lt;- rnorm(100, 0, 1.5) x3 &lt;- rnorm(100, 0, 5) # Calculate standard deviation sd1 &lt;- sdfun(x1) sd2 &lt;- sdfun(x2) sd3 &lt;- sdfun(x3) print(c(sd1, sd2, sd3)) ## [1] 1.057303 1.537626 4.901359 # Or even print(c(sdfun(x1), sdfun(x2), sdfun(x3))) ## [1] 1.057303 1.537626 4.901359 6.2 When should I use functions? A good indicator is if you start copy &amp; paste code! Copy &amp; paste means that you quite likely use the same thing (or something very similar) over and over again. Thus, think of writing a function instead! Functions can be rather simple, or already more complex allowing to control them in a way that they do the same thing but with slightly different conditions. This is done by adding additional input arguments to the function which allows one to control the function (control arguments). As soon as your code is getting more complicated: think of extracting some blocks/essential parts and put them into functions. The functions can be stored in extra script files which drastically reduces the number of lines of code in your main script and increases the readability. This helps a lot! Whenever you have a block of code you may reuse in the future, or a block of code you double-checked and you are sure it works well: you may pack it into functions. This allows you to reuse the function in the future, and, when searching for errors, you may not have to check the code inside these functions as you are sure that they work as expected. 6.3 The structure of functions Functions consist of three key elements. These are: input arguments instructions output or return values All three are optional. Well, if you have a function without instructions, the function does absolutely nothing and would be completely useless, however, technically an empty function can be created. Input and output are also optional. You may have a function which has input arguments but no output (e.g., a function that saves data to a file), or no input but output (e.g., a function that reads data from a standard file). However, these are special cases. Typically functions have at least inputs and instructions, and most will also return a result or at least an indication that the function successfully executed the instructions. 6.4 Functions in R As we have learned in an earlier session nearly anything in R is an object. Functions are first class objects as well and can be used as all the other objects or variables. This allows one to pass functions as input to other function which is frequently used and an important feature in R, even if it might be a bit confusing to people coming from other programming languages. Functions can of course also be nested (a function calls another function as part of the instructions), and functions can be used recursively (one function may call itself several times) which is useful for some tasks. Functions are often encapsulated (they take their input, do something, and return a result without touching all the objects on the workspace). However, they do not have to be encapsulated! R uses lexical scoping and functions may access variables on the workspace and/or other environments. This can be very useful, but also a bit confusing. 6.5 Calling functions Function calls are indicated by round brackets ((...)). We have already used a range of functions such as seq(...), mean(...), is.numeric(...), as.numeric(...), or plot(...) over the past weeks. A side note: R differs between functions and so called generic functions. Generic functions act differently depending on the input. For example, summary(c(&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;)) and summary(1:50) act different on character vectors and numeric vectors. We will learn something about generic functions in another session. 6.6 Naming functions You can basically use any name (as long as it is a valid variable/function name). However, you may overwrite existing functions if the function name already exists! Thus, use meaningful, clear, and unique names and try not to name all your functions f and fun and don’t use existing names such as mean or plot (except you know what you do). In R variables and functions with the same name can co-exist, e.g.,: mean &lt;- c(1, 2, 3, 4, 5, 6) mean(mean) ## [1] 3.5 Here we define a numeric vector mean and calculate the arithmetic mean by calling mean(mean). R calls the function mean using the vector mean. Even if this works try to avoid such constructs! 6.7 Functions In Real Life We all come across function-like situations in our daily life multiple times a day. One illustrative example are backing recipes. Imagine you are cooking some brownies: Classical recipes are set up as follows: A list of the required ingredients (our inputs) A set of instructions (mix this, do that, bake for 180 minutes) And a delicious foto. Or, if you cook it, some nice food! That’s the result or output. We can even find more analogies on this screenshot: The name of the recipe is like the function name, the website where we have found the recipe is the name of the R package (if the function is included in a package). Thus, every time we call this “function” (use this recipe) with this very specific name (Cocoa Brownies) from this specific package (or site, the food network) using the inputs (ingredients) as specified we will always get the same result. And that’s what functions do. 6.8 Declare Functions in R Let’s begin with an empty function. As mentioned previously all parts of a function (input, instructions, and output) are optional. If we don’t declare all three, that is what we will end up: myfun &lt;- function() { # Instructions } We define a new function called myfun by assigning a new function() to the variable myfun as you would do it with e.g., numeric values (x &lt;- 3). Function inputs will be declared within the round brackets (), but this function has no inputs. The instructions are defined inside the curly brackets {...}, in this example it is simply a comment (no code; no instructions). And last but not least, the function does not return anything at the end. However, we just defined our first custom function! As for all other objects we can examine the object using default methods such as class and is.function: # Get the class of myfun class(myfun) ## [1] &quot;function&quot; # Check if is function is.function(myfun) ## [1] TRUE To be precise: functions always return something even if nothing is explicitly declared as in our empty function myfun. Returns may be invisible as in this case, but R returns something. Let’s store the return on x and see what we got: # Declare function myfun &lt;- function() { # Instructions } # Store return on x x &lt;- myfun() # Examine print(x) ## NULL class(x) ## [1] &quot;NULL&quot; Our empty function returns a NULL (an object of class &quot;NULL&quot;). 6.9 The NULL value in R The NULL value in R is what the None type is in python. It is basically an object which tells us that it does not contain anything (so NULL basically means “nothing”). NULL objects are used quite regularly and we might, every now and then, check for is.null to check if we got an empty object. # Define variable x &lt;- NULL # Print print(x) ## NULL # Check if is null is.null(x) ## [1] TRUE 6.10 Back to functions Let us write some more useful functions. Input: no input Instructions: print a string Output: no output # Declare the function myfun &lt;- function() { print(&quot;Hello World!&quot;) } # Call function myfun() ## [1] &quot;Hello World!&quot; We can call our new myfun function by typing myfun() into the console. As we have no input, nothing has to be declared between the brackets (we are not even allowed to do so). As soon as called the function executes the instructions. Here, the string &quot;Hello World!&quot; is printed. Again, we have not explicitly declared an output or return value, but R returns us something: # Store return value/output x &lt;- myfun() ## [1] &quot;Hello World!&quot; print(x) ## [1] &quot;Hello World!&quot; class(x) ## [1] &quot;character&quot; As we can see the return, which is assigned to our variable x, contains the very same character string the function printed. Why? Well, this is a bit tricky to understand. R always returns the last return it can find. print(...) invisibly returns what it just printed. Thus, the last return was the string itself (even if we did not see it), wherefore our myfun function also returns this at the end. It is not important to know the details, but keep that in mind! We now extend our function and provide an input argument: Input: one argument called x Instructions: combine two character strings (paste) and print it Output: no explicit return value # Declare the function myfun &lt;- function(x) { print(paste(&quot;Good morning&quot;, x)) } # Call function myfun(&quot;Jochen&quot;) ## [1] &quot;Good morning Jochen&quot; We can now call our function myfun and provide (required) one input, let’s use the character string &quot;Jochen&quot; for now. The function now takes this input argument and stores it - internally - on the name x (as we named our input x). Given the instructions the function combines the two character strings &quot;Good morning&quot; and x and prints the result. Once defined we can now reuse our function myfun with different inputs: myfun(&quot;Helga&quot;) ## [1] &quot;Good morning Helga&quot; myfun(&quot;Jose&quot;) ## [1] &quot;Good morning Jose&quot; Define a return value: Input: one argument called x Instructions: combine two character strings (paste) and print it Output: return the number of characters of the pasted string Again, extend the function from above. We now define an explicit return value. But rather than just returning the combined string we are interested in the number of characters the string had. The instructions: paste the two character strings &quot;Good evening&quot; and x and store the new character string on a variable called tmp print the string tmp count the number of characters of the string tmp (that’s what nchar does; number of characters) … and return this number, an positive integer. # Declare the function myfun &lt;- function(x) { # Create the string tmp &lt;- paste(&quot;Good evening&quot;, x) # Print string print(tmp) # Return number of characters res &lt;- nchar(tmp) return(res) } # Call function, store result x &lt;- myfun(&quot;Jochen&quot;) ## [1] &quot;Good evening Jochen&quot; # Print result print(x) ## [1] 19 # Class class(x) ## [1] &quot;integer&quot; Et voila, our first “useful” function with inputs, instructions, and an explicitly defined return value or output. ### Different formulations In R things can often be written in slightly different ways. This also yields for function definitions. Even if they are all valid and do the very same thing, some of them are not recommended at all. What I recommend is to always explicitly use the return(...) command because it makes it much easier for you and all others reading your code to identify what will be returned (increase readability) Furthermore, except for very short functions, always use the curly brackets {...} as they structure your code. You can easily identify the instructions as they are written between brackets. For multi-line functions this is required anyways. Version 1: (recommended) powfun &lt;- function(x) { return(x^2) } Version 2: as a one-liner (recommended) powfun &lt;- function(x) { return(x^2) } Version 3: without brackets (ok for short functions) powfun &lt;- function(x) return(x^2) Version 4: without brackets, no explicit return (not recommended) powfun &lt;- function(x) x^2 Version 4: without brackets, no explicit return (not recommended) powfun &lt;- function(x) { x^2 } 6.10.1 Multiple input arguments Functions can have multiple input arguments and they do not have to be named x (even if often used as the first argument). The following simple function has two inputs, one called greeting, and one called name. We are expecting two strings, paste them together (paste), and return the new character string. In contrast to the functions shown earlier in this document the function itself does not print the new string, but returns it at the end of the function. # Function with two required arguments myfun &lt;- function(greeting, name) { # Store combined string res &lt;- paste(greeting, name) return(res) } Functions with multiple arguments can be used the very same way, except that we have to provide two input arguments separated by a colon. # Call the function x &lt;- myfun(&quot;Welcome to the course,&quot;, &quot;Jordan&quot;) print(x) ## [1] &quot;Welcome to the course, Jordan&quot; 6.11 Practical Session Let’s do some practical work in this session. 6.11.1 Exercise 1 write a function powfun2 with one input argument x which returns \\(x^2\\) (?Arithmetic) write a function powfun4 with one input argument x which returns \\(x^4\\) Solution: # One input argument &#39;x&#39;, returns &#39;x^2&#39; # Input: numeric vector &#39;x&#39;. # Return: numeric vector of the same # length, x to the power of 2. powfun2 &lt;- function(x) { return(x^2) } # One input argument, just for demonstration purpuses # I call it &#39;z&#39; here! Returns input^4, or z^4. # Input: numeric vector &#39;x&#39;. # Return: numeric vector of the same # length, x to the power of 2. powfun4 &lt;- function(z) { return(z^4) } 6.11.2 Exercise 2 write a function powfun with two input arguments to calculate \\(x^y\\). Return the result. Solution: The two functions from exercise 1 are extremely similar, except they use a different power parameter. If you write functions, you may write them as general as necessary. Thus, let us define one function which is able to do both: # Flexible custom power function # Input: x numeric, the &#39;base&#39; # y numeric, the power exponent # Return: Numeric vector with x^y powfun &lt;- function(x, y) { return(x^y) } Note that the function now has two inputs, namely x and y. You could add additional inputs by simply adding them (comma separated), e.g., function(x, y, a, b, foo, bar) if needed. Testing the functions: # 3 to the power of 2 powfun2(3) ## [1] 9 # 3 to the power of 4 powfun4(3) ## [1] 81 # The same with the powfun function: powfun(3, 2) ## [1] 9 powfun(3, 4) ## [1] 81 6.11.3 Exercise 3 Combine exercise 1 &amp; 2: overwrite your existing functions powfun2 and powfun4 by creating new functions with the same name. Rather than calling x^2 and x^4 explicitly these functions should internally call the function from exercise 2 and return its results (nesting functions, one of your functions internally uses another function). what happens if the inputs are vectors, what if they are vectors of different lengths? extend the function from Exercise 2, check you get valid inputs (define ‘valid’ on your own) Solution: I am sorry this was rather confusing. What I had planned is that you re-declare powfun2 and powfun4 (overwrite the existing ones) and, internally, call powfun rather than hard-coding x^2 or x^4 inside powfun2 and powfun4. So what we do is to define powfun2 &lt;- function(x) { ... } but now call powfun inside (so include powfun in the instructions {...}). For the new powfun2: As we would like to “return the input to the power of two”, we use “2” as the second input argument to “powfun”. As the first input we forward x. What happens is that we call powfun2 with some data on input x. powfun2 does not do anything with x but directly “forwards” it to the powfun function (as first input argument to powfun). The second input is “2” (always 2 in this case): # Re-declare functions powfun2 &lt;- function(x) { # Call powfun: forward &quot;x&quot;, set the second argument to &quot;2&quot; # &quot;powfun&quot; does the calculation for us. res &lt;- powfun(x, 2) return(res) } The very same for the new powfun4 but using “4” as the second argument when calling the powfun function (inside powfun4). # Re-declare functions powfun2 &lt;- function(z) { # Call powfun: forward &quot;z&quot;, set the second argument to &quot;2&quot; # &quot;powfun&quot; does the calculation for us. res &lt;- powfun(z, 2) return(res) } Again, I used z as input here to illustrate that the input of the function powfun2 is a different object/variable than the input x on powfun(x, y). What happens if call powfun with two vectors (for the two inputs) of different lengt? If x is of length 1 or y is of length 1 it is kind of obvious: # First argument 2, second argument is c(2,3,4) powfun(2, c(2, 3, 4)) ## [1] 4 8 16 The result is a vector c(\\(2^2\\), \\(2^3\\), \\(2^4\\)) (base is always 2). # First argument a vector c(2,3,4), second argument is 2: powfun(c(2, 3, 4), 2) ## [1] 4 9 16 The result is a vector c(\\(2^2\\), \\(3^2\\), \\(4^2\\)) (power exponent is always 2). # First argument a vector c(2,3,4), # the second argument is a vector c(4,3,2): powfun(c(2, 3, 4), c(4,3,2)) ## [1] 16 27 16 Now R performs element-wise or pair-wise calculation. Thus, the result is a vector c(\\(2^4\\), \\(3^3\\), \\(4^2\\)). Less obvious: if the first argument is of length 2, the second one of length 4, or the other way around. # First argument a vector c(2,3) # the second argument is a vector c(2,3,4,5): powfun(c(2, 3), c(2, 3, 4, 5)) ## [1] 4 27 16 243 The first vector is recycled to match the length of the second vector! Thus R is actually calculating c(2, 3, 2, 3)^(2, 3, 4, 5) and we get c(\\(2^2\\), \\(3^3\\), \\(2^4\\), \\(3^5\\)). This is not how I would use such a function, but to demonstrate what R does in these cases. Similar in this case: # First argument a vector c(2,3,4,5) # the second argument is a vector c(2,3): powfun(c(2, 3, 4, 5), c(2, 3)) ## [1] 4 27 16 125 The second vector is recycled to match the length of the first vector! Thus R is actually calculating c(2, 3, 4, 5)^(2, 3, 2, 3) (c(\\(2^2\\), \\(3^3\\), \\(4^2\\), \\(5^3\\))). If the two length of the vectors is not a multiple of the first one, e.g, the first is of length 2, the second of length 3, R still tries to recycle the short one, but will warn you that this is not possible. powfun(c(2, 3), c(2, 3, 4)) ## Warning in x^y: longer object length is not a multiple of shorter object ## length ## [1] 4 27 16 Checking inputs: we will learn about this in the next session, as we will make use of conditions and other control structures. Rendered: 2019-09-08 on marvin 6.12 Function Recap Just a short repetition of writing functions in R. During the last practical session but also when going trough your submissions on Session 03 Exercise A-C I’ve seen a lot of functions using Rs so called “lexical scoping” feature. Even if this works it is “not recommended to use” (at least not for beginners as it might be confusing very quickly). The following two images show two R functions. The first one is the suggested way to write functions. Explanation: The function is, again, the simple power function we have used several times. The function takes two inputs, namely x and power and returns x^power at the end. Outside the function we define a x and a y, call the function, and store the result (the return of the function) on z. Several things to mention here: Everything you use in the function should be explicitly defined as input to the function (here x and power). The objects x and power inside the function are only available inside the function (the gray box is kind of a “function container” or “box”). The object x (red) defined outside the function is not the same as the object x (turquoise) inside the function! Don’t mix them up. The “red” x is defined in our workspace. We forward the value of the “red” x to the function as the first input argument. Inside the function the first input argument is also called x but is not the “red” x. This is a new object (thus, turquoise) and gets the same value as the “red” x. The second element of the function (power) is not defined in the workspace but gets the value of y as we call the function with powfun(x, y). The function inputs do not have to match the objects outside the function. Explanation: This shows what we should not do. Scoping is a thing, but Try not to use it and try to understand what’s happening if you do. In this case the function is even wrong. What we wanted to do is to have a function which has two inputs and returns the first input (x) to the power of the second input (power). However, if you look closely we actually do something different. On our workspace we have two objects x and y. We then (as in the example above) call our function with x and y as inputs. So far, so good. The function now gets the input x and power (with the values from the two objects on our workspace), however the function returns x^y instead of x^power! Why does it still work? Scoping! We are using an object y inside the function, which has never explicitly been defined as an input to the function. R now tries to find y and will find one defined on in our workspace (the “orange” one) and uses this one. Thus, the function works and - in this case - returns the correct result, but due to the wrong reason!. The power input is never used at all. Try to imagine what will happen if you now call function(2, 2). Instead of returning 4 (2^2) the result on z will be 5.6568 as the function returns 2^y = 2^2.6 = 5.6568. Thus, always (always) define all variables you use inside functions as explicit input arguments. And check your functions such that you only use objects you specified as input arguments! 6.13 Developing Functions 6.13.1 Develop functions in steps For those who have had troubles writing functions: try to develop your functions in some kind of a multi-step approach by doing the following: Start with a fresh script and develop your code without functions first. As soon as everything works as it should, pack parts of the code into functions. Adjust and check your function. ### Step 1: start without functions As an example of a multi-step approach let’s use the example from Session 02. I start with a fresh script and develop my code to find all females in the data set which are taller than the smallest man: rm(list = objects()) # Clear the whole workspace load(&quot;height_extended.rds&quot;) # Loading the data set objects() # Check objects ## [1] &quot;age&quot; &quot;gender&quot; &quot;height&quot; &quot;name&quot; # Smallest male person smallest_male &lt;- min(height[gender == &quot;m&quot;]) print(smallest_male) ## [1] 166 # Find females taller than smallest male, store index idx &lt;- which(gender == &quot;f&quot; &amp; height &gt; smallest_male) print(idx) ## [1] 7 59 print(name[idx]) ## [1] &quot;Elisabeth&quot; &quot;Julia&quot; 6.13.2 Step 2: pack parts of your code into a function That works as expected! As I am now sure that the code runs and that my script does what it has to do I can pack it into a function. Note that the commands to clear the work space and the one command to load the data set will be outside the function, the function should only find the tall females. rm(list = objects()) # Clear the whole workspace load(&quot;height_extended.rds&quot;) # Loading the data set # Find females taller than the smallest male person tall_females &lt;- function(height, gender, name) { # Smallest male person smallest_male &lt;- min(height[gender == &quot;m&quot;]) # Find females taller than smallest male, store index idx &lt;- which(gender == &quot;f&quot; &amp; height &gt; smallest_male) print(name[idx]) } # Call function: tall_females(height, gender, name) ## [1] &quot;Elisabeth&quot; &quot;Julia&quot; 6.13.3 Step 3: adjust your function Well, that looks good so far, but now we have to adjust our function. In this case I’ve renamed my inputs (now hgt, sex, and name). WARNING: as soon as you rename your inputs: adjust your code such that it only uses these new objects (and not the old names, e.g., height). If you would use height inside the function you’ll run into the scoping problem again! In addition, I’ve added some input checks and an explicit return command at the end of the function. rm(list = objects()) # Clear the whole workspace load(&quot;height_extended.rds&quot;) # Loading the data set # Smallest male person tall_females &lt;- function(hgt, sex, name) { # Check inputs if(length(hgt) != length(sex) | length(hgt) != length(name)) { stop(&quot;Input arguments have to be of the same length&quot;) } # Find body size of smallest male person smallest_male &lt;- min(hgt[sex == &quot;m&quot;]) # Find females taller than smallest male, store index idx &lt;- which(sex == &quot;f&quot; &amp; hgt &gt; smallest_male) # Return names (character) of females &gt; smallest male return(name[idx]) } # Call function: tall_females(height, gender, name) ## [1] &quot;Elisabeth&quot; &quot;Julia&quot; 6.14 Advanced: use script files More advanced: I could now also copy the function into a second .R script file which takes up all my functions. Once I moved the function to another script I do have to source this script. source executes the script once, in this case example_functions.R. If we would not do that R would not know the function tall_females as it has never been defined! The cool thing of such function files: you can remove the function from your main script file. Especially if the functions get longer and longer this helps you to keep your main script readable. So far we have not used this, however, feel free to try (and you will, for sure, have to start using it in your coding career). Your main script would, in this example, look as follows: rm(list = objects()) # Clear the whole workspace load(&quot;height_extended.rds&quot;) # Loading the data set # Copied the function into a second file called &quot;example_functions.R&quot;. # Source function file (loads the function into the workspace) source(&quot;example_functions.R&quot;) # Call function: tall_females(height, gender, name) ## [1] &quot;Elisabeth&quot; &quot;Julia&quot; "],
["style-guide.html", "Chapter 7 Style guide", " Chapter 7 Style guide 7.0.1 What is a coding style? ``Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read.’’ Headley Wickham. ``thus try to make use of it try to follow the style guides you may thin it is kind of useless in the beginning however you will see that it is especially when your functions get more complex very useful to do so i often spent hours to find my own bugs just because my coding style was horrible keep that in mind’’ Reto, 2019. 7.0.2 Special characters do not use special characters (Umlauge, apostrophes, …) neither for object names, nor comments! you may have noticed it: object names have to start with a letter, blanks are not allowed 7.0.3 Language Preferably in English. Especially if you hand over your code to someone else. 7.0.4 Script file names Should be meaningful and use the .R suffix. Good: fit-linear-models.R utility-functions.R session02_exerciseA.R Bad: foo.R things.R exercise.R 7.0.5 Object names Should be lowercase and meaningful! Use underscores to separate words within a name. If possible use nouns for variables and verbs for functions. Good: day_one day_1 gender height smallest_male temp_kelvin Bad: the_first_day_of_month DayOne dayone djm1 foo T (existing name!) c (existing name!) mean (existing name!) 7.0.6 Spaces: infix operators Put spaces around all infix operators (+, /, *, &amp;, ==, |), around the get operator (&lt;-) and =’ s. Well written code: temp &lt;- temp * 9 / 5 + 32 volume &lt;- 4 / 3 * pi**3 if (temp == 0) print(&quot;cool&quot;) Bad code: temp&lt;-temp*9/5+32 volume&lt;-4/3*pi**3 if( temp==0) print(&quot;cool&quot;) 7.0.7 Spaces: colons One exception: There is no space around colons (:, ::, :::): Good: x &lt;- 1:10 Bad: x &lt;- 1 : 10 7.0.8 Spaces: multiple spaces Ok to use multiple spaces if it increases readability. E.g.: More well-structured … list( total = l + b + h, mean = (l + b + h) / 3, variance = var(c(l + b + h)) ) … than this: list( total = l + b + h, mean = (l + b + h) / 3, variance = var(c(l + b + h)) ) 7.0.9 Spaces: brackets A space before opening round brackets (() and after closing round brackets ()) except for function calls. Good: if (a == 4) if (debug) print(x) mean(x) plot(x, y, col = &quot;red&quot;) Bad: if(a==4) if(debug)print(x) mean (x) plot (x,y,col=&quot;red&quot;) 7.0.10 Spaces: commas Always use spaces after the comma. Good: x &lt;- c(1, 2, 4) x &lt;- mat[1, ] plot(x, y, col = &quot;red&quot;) Bad: x &lt;- c(1,2,4) x &lt;- mat[1,] plot(x,y,col = &quot;red&quot;) 7.0.11 Opening/closing brackets Opening curly brackets should never go in a new line, but should always be followed by a new line. Final closing curly brackets should be in a separate line. Good: if (a == 10) { res &lt;- TRUE } else { res &lt;- FALSE } myfun &lt;- function(x) { # Instructions } Bad: if (a == 10) { res &lt;- TRUE } else { res &lt;- FALSE} 7.0.12 Indention Use block-wise indention (RStudio supports you). Suggested by Headley: use two spaces as indent. Good: powfun &lt;- function(x) { res &lt;- x**y return(res) } Bad: powfun &lt;- function(x) { res &lt;- x**y return(res) } For very short statements: powfun &lt;- function(x, y) { return(x^y) } if (a == 10) { res &lt;- TRUE } powfun &lt;- function(x, y) return(x^y) if (a == 10) res &lt;- TRUE 7.0.13 Explicit return My personal suggestion: explicitly use the command when returning results from a function! Good: powfun &lt;- function(x) { res &lt;- x^2 return(res) } powfun &lt;- function(x, y) return(x^y) Bad: powfun &lt;- function(x) { res &lt;- x^2 res } powfun &lt;- function(x, y) x^y 7.0.14 Line breaks Line breaks: lines should not be longer than 80 characters. Use line breaks for long statements. Good: data &lt;- c(firstname = &quot;Reto&quot;, lastname = &quot;Stauffer&quot;, city = &quot;Innsbruck&quot;, zipcode = &quot;6020&quot;, department = &quot;Department of Statistics&quot;) Bad: data &lt;- c(firstname = &quot;Reto&quot;, lastname = &quot;Stauffer&quot;, city = &quot;Innsbruck&quot;, zipcode = &quot;6020&quot;, department = &quot;Department of Statistics&quot;) 7.0.15 Nested indention Use block-wise indention (RStudio supports you). Use two spaces as indent. Good: demo_function &lt;- function(x) { if (a == 3) { res &lt;- &quot;This&quot; } else { for (i in 1:10) { res &lt;- a + i } } return(res) } Bad: demo_function &lt;- function(x) { if (a == 3) { res &lt;- &quot;This&quot; } else { for (i in 1:10) { res &lt;- a + i } } return(res) } 7.0.16 Object assignment Use &lt;- and not =. Good: a &lt;- 5 powfun &lt;- function(x, y) return(x^y) Bad: a = 5 powfun = function(x, y) return(x^y) 7.0.17 Comments Start to write comments! Again: code is more often read then written, comments help to understand code (also your own!). Use # ------ or # ======== to separate code blocks. # ----------------------------- # Define variables x &lt;- seq(0, 100, length = 100) y &lt;- sin(x / pi * 180) # ----------------------------- # Create plot plot(x, y, col = 5) 7.0.18 All together Both code chunks do the very same. And both will work. I think there’s nothing to say here! Good: demo_function &lt;- function(x) { if (a == 3) { res &lt;- &quot;This&quot; } else { for (i in 1:10) { res &lt;- a + i } } return(res) } Very, very bad: DmoFn&lt;-function(x) {if(a==3) {res &lt;- &quot;This&quot; }else{ for(i in 1 :10) { res= a +i}} res} "],
["control-structures-1.html", "Chapter 8 Control Structures (1) 8.1 Logical Operators 8.2 If conditions 8.3 If else conditions", " Chapter 8 Control Structures (1) So far we have only written very simple functions and scripts which always did the very same. To make the code more dynamic we need so called control statements. The following ones exist in R and we will learn how they work over the next few sessions. if and : test a condition and act on it for: loop over a fixed number of items while: execute loop while a condition is TRUE repeat: an infinite loop (until break stops it) break: stop/break execution of a loop next: skip iteration, continue loop return: exit a function (returns result) The following comic can be seen as a function with a set of control statements. the whole flowchart can be seen as a function start_homework there are a set of if-else conditions (if something is Yes do this, else to that) the loop in the bottom right corner is a while loop. While (or “as long as”) more than 12 hours left until submission: procrastinate. 8.1 Logical Operators Logical operators are an essential part of control structures. Check “Session 02, Exercise B” and read the R documentation ?Logical and ?Comparison (help pages) for more details. 8.2 If conditions The most basic control structure is the single if condition. Basic usage: Structure: if (&lt;condition&gt;) { &lt;action&gt; } The condition has to be a single logical value (TRUE or FALSE). The action between the curly brackets is executed if and only if the condition is TRUE. An example: # Define x x &lt;- 8 # Check if x &gt; 10 if (x &gt; 10) { print(&quot;x is larger than 10&quot;) } if (x &gt; 10) print(&quot;x is larger than 10&quot;) There are different ways how to write if conditions. According to Headley Wickhams style guide the following two ways are the preferred ones: Short: if (x &gt; 10) print(&quot;x is larger than 10&quot;) For longer &lt;action&gt;s on multiple lines: if (x &gt; 10) { print(&quot;x is larger than 10&quot;) } That’s nice, but where can we use it? 8.2.1 Conditional return Session 03, Exercise B: pool price. calculate_costs &lt;- function(width, height, depth, price) { # If input price is smaller or equal to 0 return NA if (price &lt;= 0) return(NA) # Else do something res &lt;- width * height * depth * price return(res) } 8.2.2 Stop execution We can now use conditions to stop our script conditional on e.g., our input arguments using stop(&quot;...&quot;). Don’t mix stop with quit(...)! quit will quit RStudio (or R in general), stop stops the execution of a script. In this example the execution will be stopped if the inputs are not numeric (x and/or y). powfun &lt;- function(x, y) { # Check if x, y are numeric if (!is.numeric(x)) stop(&quot;input x has to be numeric&quot;) if (!is.numeric(y)) stop(&quot;input y has to be numeric&quot;) # Return the result return(x^y) } We can, of course, add a set of different checks, e.g., check that both inputs are numeric and of length 1: powfun &lt;- function(x, y) { # Check if x, y are numeric if (!is.numeric(x)) stop(&quot;input x has to be numeric&quot;) if (!is.numeric(y)) stop(&quot;input y has to be numeric&quot;) # Both have to be of length one if (length(x) != 1) stop(&quot;input x has to be of length 1&quot;) if (length(y) != 1) stop(&quot;input y has to be of length 1&quot;) # Return the result return(x^y) } This is the very same (again, check that x and y are numeric of length 1) but using logical or (|): powfun &lt;- function(x, y) { # Check if x, y are numeric if (!is.numeric(x) | !is.numeric(y)) { stop(&quot;input x, y have to be numeric&quot;) } # Both have to be of length one if (length(x) != 1 | length(y) != 1) { stop(&quot;input x, y have to be of length 1&quot;) } # Return the result return(x^y) } Or using only one condition. Note: compare this version to the one two further up. While they do the same this one is much more compact, however, the error message you will get is much less detailed. Thus, if you get an error here (stop(...) is called) it is not obvious what happened exactly. Thus, it strongly depends on your task whether you want to have compact conditions or detailed messages. powfun &lt;- function(x, y) { # Check if x, y are numeric and of length 1 if (!is.numeric(x) | !is.numeric(y) | length(x) != 1 | !length(y) == 1) { stop(&quot;input x, y have to be numeric of length 1&quot;) } # Return the result return(x^y) } 8.2.3 Another example Another example from Session 03, Exercise A: celsius_to_fahrenheit &lt;- function(x) { if (!is.numeric(x)) stop(&quot;x must be numeric&quot;) return(x * 9 / 5 + 32) } fahrenheit_to_celsius &lt;- function(x) { if (!is.numeric(x)) stop(&quot;x must be numeric&quot;) return((x - 32) * 5 / 9) } We cannot only check input arguments using control statements, we can also use them to check results and other things. Remember: in Session 02, Exercise A one of the tasks was to convert temperatures from degrees Celsius to degrees Fahrenheit and back and check if the temperatures are the same at the end. If not, you have a problem with your functions. Let’s start with a numeric vector temp_celsius and convert the temperatures into degrees Fahrenheit and back. The resulting vector is temp_celsius2. # Convert temperatures temp_celsius &lt;- c(0.3, -5.2, 38.3, NA, 34.1) temp_fahrenheit &lt;- celsius_to_fahrenheit(temp_celsius) temp_celsius2 &lt;- fahrenheit_to_celsius(temp_fahrenheit) We could now use an if condition in our script to compare these two vectors and stop if they are not equal before using them to calculate something else. # Stop if not equal if (!all.equal(temp_celsius, temp_celsius2)) { stop(&quot;Whoops, something is wrong with the conversion&quot;) } 8.3 If else conditions The next extension of simple if statements are the if-else statements. Structure: if (&lt;condition&gt;) \\{ &lt;action 1&gt; \\} else \\{ &lt;action 2&gt; \\} Additional else code block (optional) If the condition is TRUE “&lt;action 1&gt;” is executed, else “&lt;action 2&gt;”. A simple example: # Create object x x &lt;- 22 # Is a larger than 10? if (x &gt; 10) { print(&quot;x is &gt; 10&quot;) } else { print(&quot;x is &lt;= 10&quot;) } ## [1] &quot;x is &gt; 10&quot; Again, R allows you to write if-else conditions differently. According to the style guide the following to ways are good: One-liner: if (x &gt; 10) { print(&quot;x is larger than 10&quot;) } else { print(&quot;x is smaller or equal to 10&quot;) } Over multiple lines: if (x &gt; 10) { print(&quot;x is larger than 10&quot;) } else { print(&quot;x is smaller or equal to 10&quot;) } 8.3.1 Multiple conditions We can also combine multiple if-else conditions and next them. In this example the else action contains another if-else control statement. x &lt;- 10 # First if-else statement if (x &lt; 10) { x &lt;- x^2 } else { # Second if-else statement (nested) if (x &gt; 10) { print(&quot;The result is larger than 10!&quot;) } else { print(&quot;Exactly 10!&quot;) } } In this example &quot;Exactly 10!&quot; will be printed. The outer condition (x &lt; 10) is FALSE why “else” will be executed. In else we see a second if-else block. The condition of this inner if-else statement is also FALSE (x &gt; 0) wherefore “else” of the inner control statement will be executed. ### if, else if, else The next and last extension are additional else if conditions. They are executed sequentially! If the first condition (if) is FALSE check the next condition Check first else if condition. If TRUE execute, else check the next one (in this case it’s else). Note that only one will be used! x &lt;- 4 # One if, else if, else condition if (x &lt; 10) { x &lt;- x^2 } else if (x &gt; 10) { print(&quot;The result is larger than 10!&quot;) } else { print(&quot;Exactly 10!&quot;) } In this example nothing will be printed. The first condition (x &lt; 10) is TRUE and the first action will be executed. All done there is to take x to the power of 2 (x &lt;- x^2). This will change our x and x will be 16 at the end (4^2) but we will not run into else if as the first if was TRUE and only one will be executed! We can use multiple else if conditions. Again: only one will be executed, the first one that is TRUE (or run into the else if none of them is TRUE. All others will be skipped. Another example: what will be printed, if anything? x &lt;- 4 # First condition if (x &lt; 10) { x &lt;- x^2 } # Second condition if (x &gt; 10) { print(&quot;The result is larger than 10!&quot;) } else { print(&quot;Exactly 10!&quot;) } In contrast to the one example two further up we are not using an if, else if, else here, but an if, and a second if-else! Thus, something different happens. These are two separate control structures and the will be executed one after another. x &lt; 10 is true, so the action of the upper if statement will be executed. The action is x &lt;- x^2 which will overwrite our object x and store 16 on x. Now the second if-else statement is considered. As we have modified our x the condition x &gt; 10 is TRUE and &quot;The result is larger than 10!&quot; will be printed. "],
["control-structures-2.html", "Chapter 9 Control Structures (2) 9.1 Control Structures 9.2 for loops 9.3 Basic usage 9.4 For loops over vectors 9.5 Combine loops and if/else conditions 9.6 Use next and break 9.7 Practical exercises 9.8 Looping over vector indices 9.9 Using next and break 9.10 while loops 9.11 Store Interim Results 9.12 Practical Session", " Chapter 9 Control Structures (2) TODO this is a copy of the one above, at leas in large parts. Merge. Graphical representation: Simple representation of an if-else control structure. Simple representation of an if, else if, else control structure. 9.1 Control Structures Last time we have been looking at if conditions which allow you to conditionally execute code. This time we will have a quick look at for, while, and repeat loops and the break, next, and return keywords/functions. if and : test a condition and act on it for: loop over a fixed number of items while: execute loop while a condition is TRUE repeat: an infinite loop (until break stops it) break: stop/break execution of a loop next: skip iteration, continue loop return: exit a function (returns result) 9.2 for loops for loops are used frequently when writing scripts to execute a set of instructions multiple times e.g.: read a set of input files do calculations for a set of values search for specific data … 9.3 Basic usage Structure: for (&lt;value&gt; in &lt;values&gt;) { &lt;action&gt; } &lt;value&gt; is the current ``loop object'',` a set of (different) values over which one would like to iterate the &lt;action&gt; is executed for each &lt;value&gt; in &lt;values&gt; &lt;values&gt; can be vectors or lists, typically vectors are used (integer vectors, numeric vectors, or character vectors) Note: R has no for-loop constructor like for (i = 1; i &lt;= n; i++) { ... } as many other programming languages do. The R equivalent would is for (i in 1:n) { ... } 9.4 For loops over vectors The following for loop iterates over an integer vector c(1L, 2L, 3L) starting with i = 1L and iterates over i = 2L and i = 3L. The for loop ends after iterating over all elements in the vector. # For loop over an integer # vector with 3 elements for (i in c(1L, 2L, 3L)) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 In R we can also use a character vector to loop over. E.g., looping over a set of names (character vector c(&quot;Reto&quot;, &quot;Ben&quot;, &quot;Lea&quot;), the loop object here is called name: # For loop over a character # vector with 3 elements for (name in c(&quot;Reto&quot;, &quot;Ben&quot;, &quot;Lea&quot;)) { print(name) } ## [1] &quot;Reto&quot; ## [1] &quot;Ben&quot; ## [1] &quot;Lea&quot; Instead of writing for (i in c(1L, 2L, 3L)) ... we can also loop over an existing object. In the example below we create an integer vector x &lt;- 1:5 which we use in the for loop. # Define the vector over # which we will loop x &lt;- 1:5 # For loop for (i in x) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 The very same yields for character vectors. # Define the vector over # which we will loop participants &lt;- c(&quot;Reto&quot;, &quot;Ben&quot;, &quot;Lea&quot;) # For loop for (name in participants) { print(name) } ## [1] &quot;Reto&quot; ## [1] &quot;Ben&quot; ## [1] &quot;Lea&quot; We can also define a for loop over a “reverse” sequence (a decreasing sequence), e.g., a sequence 3, 2, 1 by either defining a decreasing sequence 3:1: # Looping &quot;backwards&quot; # (decreasing integers) for (i in 3:1) { print(i) } ## [1] 3 ## [1] 2 ## [1] 1 or by using the rev(...) (reverse) function. The reverse function simply reverses all elements. Thus, rev(c(1L, 2L, 3L)) is identical to c(3L, 2L, 1L): # Or using &quot;rev&quot; (reverse) x &lt;- 1:3 for (i in rev(x)) { print(i) } ## [1] 3 ## [1] 2 ## [1] 1 The very same yields for character vectors. participants &lt;- c(&quot;Reto&quot;, &quot;Ben&quot;, &quot;Lea&quot;) for (name in rev(participants)) { print(name) } ## [1] &quot;Lea&quot; ## [1] &quot;Ben&quot; ## [1] &quot;Reto&quot; Loops can also be nested. Most often this is used in a matrix context (looping over data in a matrix). We will talk about matrices next week! Frequently used: a nested for loop over two loop indices called i and j (in matrices corresponding to rows and columns). # Nested for loops for (i in 1:3) { for (j in 1:2) { print(c(i, j)) } } The outer for loop iterates over i = c(1L, 2L, 3L), the inner one over j = c(1L, 2L). The result is the following: # Nested for loops for (i in 1:3) { for (j in 1:2) { print(c(i, j)) } } ## [1] 1 1 ## [1] 1 2 ## [1] 2 1 ## [1] 2 2 ## [1] 3 1 ## [1] 3 2 At first, the outer loop sets i = 1L and executes its instructions (the inner for loop). The inner for loop sets j = 1L (thus, the first print prints 1 1; i = 1L, j = 1L). As the inner for loop is not yet finished, j will be set to j = 2L and we get the output 1 2 (i = 1L, j = 2L). After that the inner loop finished, thus we proceed with the outer loop and set i = 2L and, again, execute the instructions (which is the inner for loop). The inner loop now iterates over j = 1L and j = 2L again which gives us the output 2 1 and 2 2. Then, i is set to i = 3, the inner loop is executed once more (gives 3 1 and 3 2). Now the outer loop is finished and the script ends. 9.5 Combine loops and if/else conditions To create more dynamic loops we can also combine loops (not limited to for loops) with additional control structures such as if statements. The example below loops over i in 1:n (as n &lt;- 3L it loops over i = 1L, i = 2L, and i = 3L) and, conditional in i, a string is printed. # Upper limit for the loop n &lt;- 3L for (i in 1:n) { if (i &lt; n) { print(&quot;ice&quot;) } else { print(&quot;baby&quot;) } } ## [1] &quot;ice&quot; ## [1] &quot;ice&quot; ## [1] &quot;baby&quot; There are special control statements for loops, namely return (only used for loops in functions), next, and break. 9.6 Use next and break next and break are no functions but control statements (simply next or break, not next() or break()). next is used to skip one iteration. Whenever called inside a loop, the current iteration of this loop is skipped and the loop continues with the next iteration (but does not stop). the break statement stops the execution of the loop. Can be used to stop the execution of a loop early. 9.6.1 How to use next The following lines show how next can be used in a loop. We have a for loop which iterates over all &lt;var&gt; in &lt;vars&gt; and has an additional if condition. Whenever this condition is TRUE, next is called which skips the current iteration and proceeds with the next one (next &lt;var&gt; in the sequence &lt;vars&gt;). for (&lt;var&gt; in &lt;vars&gt;) { if (&lt;condition) { next } } 9.6.2 How to use break Very similar to the example above we are looping over a set of &lt;var&gt; along &lt;vars&gt;. As soon as the additional if &lt;condition&gt; is TRUE, break will be called. break will immediately stop the iteration no matter at which position of &lt;vars&gt; we are. for (&lt;var&gt; in &lt;vars&gt;) { if (&lt;condition&gt;) { break } } 9.7 Practical exercises A: Write a for loop which iterates over an integer sequence from = 1 up to = 30 and print the loop variable. B: Use the same loop as in A, but break if loop variable is larger than or equal to 10. C: Use the same loop as in A, print the loop variable and whether it is odd or even. D: Use the same loop as in A, skip all odd numbers using next. 9.8 Looping over vector indices Quite often you will loop over a set of indices (e.g., for (i in 1:100)) and use these indices to access data in vectors, lists, matrices, and other objects. If you forgot how vector subsetting by indices work please go trough the “Vector Subsetting” section of Session 02 (Help &amp; Vectors). As an example: Let’s imagine we have two character vectors of the same length called first_name and last_name containing the names of some individuals. The first element in a vector in R is always index 1 (not 0 as in other programming languages), the last element in this example is 6 as the vectors have a length of 6 (length(first_name) is 6). Thus, we can do something like this: # Two character vectors with a set of names first_name &lt;- c(&quot;Lea&quot;, &quot;Sabine&quot;, &quot;Mario&quot;, &quot;Lea&quot;, &quot;Peter&quot;, &quot;Max&quot;) last_name &lt;- c(&quot;Schmidt&quot;, &quot;Gross&quot;, &quot;Super&quot;, &quot;Kah&quot;, &quot;Steiner&quot;, &quot;Muster&quot;) # Loop over indizes for (i in 1:6) { print(first_name[i]) } ## [1] &quot;Lea&quot; ## [1] &quot;Sabine&quot; ## [1] &quot;Mario&quot; ## [1] &quot;Lea&quot; ## [1] &quot;Peter&quot; ## [1] &quot;Max&quot; The for loop iterates over an integer vector (1:6) containing the values 1L, 2L, …, 6L wherefore i = 1L for the first iteration, i = 2L for the second iteration, and so far and so on. Using vector subsetting by index we can now print the ith element of our vector first_name by simply calling print(first_name[i]). A slightly more useful example (yes, we could solve it without loops) is the following: We will loop over i in 1:6 and check if the ith element of the vector first_name is &quot;Lea&quot;. If the condition is TRUE we have found a person called &quot;Lea&quot; and we will print her full name. # Two character vectors with a set of names first_name &lt;- c(&quot;Lea&quot;, &quot;Sabine&quot;, &quot;Mario&quot;, &quot;Lea&quot;, &quot;Peter&quot;, &quot;Max&quot;) last_name &lt;- c(&quot;Schmidt&quot;, &quot;Gross&quot;, &quot;Super&quot;, &quot;Kah&quot;, &quot;Steiner&quot;, &quot;Muster&quot;) # Loop over indizes for (i in 1:6) { if (first_name[i] == &quot;Lea&quot;) { print(paste(&quot;Found a&quot;, first_name[i], last_name[i])) } } ## [1] &quot;Found a Lea Schmidt&quot; ## [1] &quot;Found a Lea Kah&quot; The only thing which is not so nice is that we have hardcoded 1:6 here. As soon as you would get a new vector of names the script would not work anymore (as you may iterate over the wrong number of elements). Thus, we should try to avoid such hard-coded commands/instructions in our code whenever possible. There are two options to do so. Most obvious is to replace 6 by length(first_name). If you change the length of first_name we will still loop over all elements. Another way in R to do the same is to call the seq_along function. seq_along(x) returns an integer sequence from = 1 to to = length(x) (in our case x is our object first_name) and can thus be used for looping over an object. 1:length(first_name) # Use &quot;length(first_name)&quot; ## [1] 1 2 3 4 5 6 seq_along(first_name) # Use seq_along ## [1] 1 2 3 4 5 6 Et voila: # Use &quot;length(first_name)&quot; instead of hard-coding 6 for (i in seq_along(first_name)) { if (first_name[i] == &quot;Lea&quot;) { print(paste(&quot;Found a&quot;, first_name[i], last_name[i])) } } ## [1] &quot;Found a Lea Schmidt&quot; ## [1] &quot;Found a Lea Kah&quot; 9.9 Using next and break The for loop above prints the name as soon as first_name[i] == &quot;Lea&quot;. We could also program it the other way around and do the following: # Loop over indizes for (i in seq_along(first_name)) { # We want to find only &quot;Lea&quot;s if (first_name[i] != &quot;Lea&quot;) next # Else print print(paste(&quot;Found a&quot;, first_name[i], last_name[i])) } ## [1] &quot;Found a Lea Schmidt&quot; ## [1] &quot;Found a Lea Kah&quot; As described earlier, next skips the current iteration. In this example we check first_name[i] != &quot;Lea&quot;. If this is TRUE (if this is not a &quot;Lea&quot;) we call next which skips this iteration/person. Thus, the print command is only executed when first_name[i] != &quot;Lea&quot; is FALSE, or in other words, whenever first_name[i] == &quot;Lea&quot;. An example for the break statement: We still have the same character vectors first_name and last_name and we will find the first person called &quot;Mario&quot;, but only one. To do so we can do the following: # Loop over indizes for (i in seq_along(first_name)) { # We want to find only &quot;Lea&quot;s if (first_name[i] == &quot;Mario&quot;) { print(paste(&quot;Found someone called&quot;, last_name[i], first_name[i])) break } print(paste(i, &quot;is no Mario&quot;)) } ## [1] &quot;1 is no Mario&quot; ## [1] &quot;2 is no Mario&quot; ## [1] &quot;Found someone called Super Mario&quot; The for loop is again looping over all elements i in seq_along(first_name) and checks if the element first_name[i] of the current iteration is &quot;Mario&quot;. As soon as the script finds a &quot;Mario&quot; the condition first_name[i] == &quot;Mario&quot; is TRUE and the name of the person is printed. After the print command break is called which immediately stops the for loop execution. Thus, the for loop stops at i = 3 as the 3th person is a &quot;Mario&quot;. 9.10 while loops Another loop constructor is while. while executes a set of instructions while a condition is TRUE (or, until the condition is FALSE). Basic usage Structure: while (&lt;condition&gt;) { &lt;action&gt; } The &lt;condition&gt; has to be logical FALSE or TRUE. The &lt;action&gt; is executed as long as the &lt;condition&gt; is TRUE. WARNING: Take care of infinite loops! The following code chunk will run forever. # Define x x &lt;- 1 # Increase x by 1 as long as ... while (x &lt; 0) { x &lt;- x + 1 } An example for a while loop: Print all numbers x in \\(1, 2, ..., \\infty\\) as long as x^2 is lower than 20. Start with x &lt;- 0. Iteration 1: \\(0^2 = 0\\) and thus lower than 20 (the condition is TRUE). At the end x is increased by 1 (x &lt;- x + 1) and the next iteration is started. Iteration 2: x is now 1, \\(1^2 = 1\\) is still &lt; 20 and the condition is still TRUE. Thus, increase x and continue. Iteration 3: x is 2, \\(2^2 = 4\\), x^2 &lt; 20 is TRUE, increase x, continue. Iteration 4: x is 3, \\(3^2 = 9\\), x^2 &lt; 20 is TRUE, increase x, continue. Iteration 4: x is 4, \\(4^2 = 16\\), x^2 &lt; 20 is TRUE, increase x, continue. Iteration 5: x is now 5. As \\(5^2 = 25\\) the condition x^2 &lt; 20 is no longer TRUE and the while loop stops. # Start with 0 x &lt;- 0 # Loop until condition is FALSE while (x^2 &lt; 20) { print(x) # Print x x &lt;- x + 1 # Increase x by 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 9.11 Store Interim Results Often you would like to keep interim results (the values of the different iterations) rather than only having the one value at the very end of the loop. To do so we have to store the result of each iteration into a suitable object, e.g., a numeric vector. An example: Let us try the following. We will start with an initial value of 1.0 and multiply it by 1.5 six times. We could write it as follows: x &lt;- 1.0 for (i in 1:6) { x &lt;- x * 1.5 } print(x) ## [1] 11.39062 And we can see that the result is 11.390625. However, we might be interested in the interim steps (what is 1.0 * 1.5, what is 1.0 * 1.5 * 1.5 and so far and so on). To do so let’s create an empty numeric vector x of length 7 using vector(&quot;numeric&quot;, 7). The exercise was to multiply 1.5 six times, however we also have to store our initial value on x wherefore we need 7 elements in our vector (and not 6). This creates a vector containing 7 0s. On the first element (x[1L] we store our initial value 1.0. N &lt;- 7 # Length of the vector x &lt;- vector(&quot;numeric&quot;, N) # Empty vector of length N x[1L] &lt;- 1.0 # Set the first element to 1.0 print(x) ## [1] 1 0 0 0 0 0 0 In let’s write the for loop. The first element contains our initial value, thus we will loop over i = 2:7 (i in c(2, 3, 4, 5, 6, 7); which is 6 iterations). In each iteration we take the previous element of x (e.g., when i = 2 we will use x[i - 1] = x[1L]; the first element), multiply this element with 1.5, and directly store it on x[i] = x[2L]. In the next iteration we do the same but using i = 3L and so far and so on. # Loop over 2:N, store results in x for (i in 2:N) { x[i] &lt;- x[i - 1L] * 1.5 } print(x) ## [1] 1.00000 1.50000 2.25000 3.37500 5.06250 7.59375 11.39062 But let us do this step-by-step. In a first step we defined ourself a vector x of length 7. We can “visualize” this vector as follows: By index, the first element of the vector is x[1L], the second one x[2L] and so far and so on (R starts with 1, not 0). Given a second object i = 1L (a vector index) we can also rewrite this as follows: x[i] is the first element as i = 1L. The second element is x[i + 1L] as i + 1L = 2L, and the last one x[i + 6L] as we have 7 elements (i + 6L = 7L). In our example (multiply 1.0 six times with 1.5) we first define a vector of length 7 and set x[1L] to 1 which gives us the following numeric vector: So far, not very impressive. N &lt;- 7 # Length of the vector x &lt;- vector(&quot;numeric&quot;, N) # Empty vector of length N x[1L] &lt;- 1.0 # Set the first element to 1.0 print(x) ## [1] 1 0 0 0 0 0 0 In the second step we write the for loop, looping over i = 2:7. for (i in 2:7) { x[i] &lt;- x[i - 1] * 1.5 } In the first iteration of the for loop i is set to 2L. Inside the loop we compute x[i - 1] * 1.5 and directly store it on x[i]. Thus, we store x[1L] * 1.5 on x[2L] (or x[2L] &lt;- x[1L] * 1.5). In the next iteration i is set to 3L and we store x[3L] &lt;- x[2L] * 1.5 and so far ans so on … … until we reach x[7L] &lt;- x[6L] * 1.5, the end of our loop. At the end we have stored all the interim results on x which now looks as follows: for (i in 2:7) { x[i] &lt;- x[i - 1] * 1.5 } print(x) ## [1] 1.00000 1.50000 2.25000 3.37500 5.06250 7.59375 11.39062 Another way to store interim results is to append(...). append(x, y) simply appends y to x (identical to c(x, y)). This is especially required if we don’t know the final length of our object, in this case x. The following while loop does the following: Start with x &lt;- 1. In each iteration set x &lt;- x * 1.5. As long as x &lt; 100 continue. As we are not looping over a fixed number of iterations (e.g., for (i in 1:5)) we do not know how many iterations will be necessary until x &gt;= 100. Thus, we have to store our results differently. Create a second object res and store the initial value on it (res &lt;- x). In each iteration append the new x to res. This adds the new x at the end of res and increases the length of res by 1. x &lt;- 1 # Initial value of x: will be modified res &lt;- x # Store initial value on &quot;res&quot; while (x &lt; 100) { # Compute new x x &lt;- x * 1.5 # Append new x to vector &quot;res&quot; res &lt;- append(res, x) } print(res) ## [1] 1.00000 1.50000 2.25000 3.37500 5.06250 7.59375 11.39062 ## [8] 17.08594 25.62891 38.44336 57.66504 86.49756 129.74634 print(length(res)) ## [1] 13 Our final object res is of length 13. 12 iterations were required until x got &gt;= 100 (12 iterations but length 13 as we also stored our initial value on res). Note: if possible try to define your vector in advance (much faster). However, this is only possible if you know how many iterations will be required (e.g., in the for loop). If not, append(...) can be used. 9.12 Practical Session 9.12.1 Exercise 1: Arithmetic mean Calculate the arithmetic mean over a sequence of random numeric values from a Gaussian distribution (rnorm(...)) using a for loop (without sum(...) and mean(...)). The arithmetic mean is defined as: \\(\\bar{x} = \\frac{1}{N} \\sum_{i=1}^N \\big(x_i\\big)\\) set.seed(100) # Fix random numbers x &lt;- rnorm(12) # Draw a set of random numbers print(x) ## [1] -0.50219235 0.13153117 -0.07891709 0.88678481 0.11697127 ## [6] 0.31863009 -0.58179068 0.71453271 -0.82525943 -0.35986213 ## [11] 0.08988614 0.09627446 # What is the mean of x? 9.12.2 Exercise 2: Conditional for loop set.seed(7) x &lt;- sample(-10:20, size = 15, replace = TRUE) print(x) ## [1] -1 8 20 17 -4 -9 4 15 11 -3 13 -8 13 -3 11 Write a for loop (do not hard-code i in 1:15 which loops over the vector and divide all negative values by 5. Loop over the original vector x using a for loop. If an element is negative: overwrite it with the previous element in the vector (e.g., replace -7 with 2). Do the same but replace with next element. What happens if you use different random numbers? 9.12.3 Exercise 3: Factorial In mathematics, the factorial of a positive integer \\(n\\) (denoted by \\(n!\\)) is the product all positive integers less than or equal to \\(n\\) (and, by definition, \\(0! = 1\\)). An example: \\(3! = 1 \\times 2 \\times 3 = 6\\) Write a small function which takes one input argument n which returns n! using a for loop. Try the same using a while loop. Hint: You may use a decreasing sequence, e.g., i in 3:1! "],
["matrices.html", "Chapter 10 Matrices 10.1 Matrices in R 10.2 Create a matrix 10.3 Fill by row/column 10.4 Column-binding and row-binding (vectors) 10.5 Column-binding and row-binding (matrices) 10.6 Matrix attributes 10.7 Setting dimension names (, ) 10.8 Set dimension names when creating the object 10.9 Practical Exercises (part 1) 10.10 Subsetting matrices 10.11 Subsetting matrices with logical vectors 10.12 Subsetting by name 10.13 Non-existing elements in matrices 10.14 The subset method 10.15 Matrix Arithmetic 10.16 Further functions 10.17 Practical Exercises (part 2) 10.18 Typical Examples", " Chapter 10 Matrices In one of the first sessions I’ve shown the following image which explains how the different objects are connected to each other and/or based on each other. So far, we have learned a lot about (atomic) vectors, one of the basic objects in R. In this session we will see how matrices, data frames, and lists work. As shown, matrices are based on vectors, while data frames are based on lists, another frequently used object type in R. But let’s start with matrices first! 10.1 Matrices in R matrices are based on vectors can only contain data of one class (or mode; as vectors) have a dimension attribute (dim) can have row and column names (rownames, colnames) Matrices can be created using the matrix function (see ?matrix or help(&quot;matrix&quot;). According to the R documentation the usage of the matrix function is as follows: matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) data: a data vector (default NA) nrow: integer, number of rows (default 1) ncol: integer, number of columns (default 1) byrow: logical, whether or not to fill by row (default by column) dimnames: optional list of length 2 with rownames and column names. Function defaults: functions can have required inputs (as seen in the lecture), but also optional input arguments with defaults. If an input has a default (e.g., data = NA) the default value as defined is used if we do not define this input. Thus, the call matrix() will create a matrix containing NA (data = NA) with one row (nrow = 1) and one column (ncol = 1). Generic methods for matrices For matrices (and most other objects) a set of so called generic methods or functions exist. Some useful methods for matrices are: head(x, n = N): show first \\(N\\) rows tail(x, n = N): show last \\(N\\) rows summary(x): object summary rbind(x1, x2): row-bind two matrices cbind(x1, x2): column-bind and column-bind subset: subsetting a matrix … and many others … Note that these are generic methods and they will also work on other objects (e.g., vectors or data frames). 10.2 Create a matrix The following examples show how to create matrices of different dimensions with and without data. To create a matrix of the dimension \\(2 \\times 3\\) without data we can call: # NA matrix, dimension 2x3 matrix(nrow = 2, ncol = 3) ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA Remember that the default for the input data is NA. As we have not specified data the whole matrix will be filled with missing values. The two additional arguments define the matrix size with two rows and three columns (\\(2 \\times 3\\) matrix). Instead of creating an empty matrix we can also directly provide data. In this case, an integer sequence 1:9 is used. # Matrix containing 1-9 (3x3) matrix(data = 1:9, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 Note: we do not provide the ncol argument. Our data set is of length 9 (length(1:9)) and we are asking for three rows. There is only one way to fulfil the requirements: creating a \\(3 \\times 3\\) matrix. A graphical representation of what is happening is shown below: The upper part of the image represents a vector, e.g., the vector of length 9 shown in the example (1:9). The bottom figure shows how the vector is represented in the matrix, a \\(3 \\times 3\\) matrix in this example. By default **the data is filled by column, wherefore the first (left) column will contain the values 1, 2, 3, the next column 4, 5, 6, and the last column the remaining values 7, 8, 9. We can change this behavior … 10.3 Fill by row/column The matrix by default uses byrow = FALSE and fills in the data by column (as shown above). However, we can set byrow = TRUE to fill in the data by row (top row first). The following two chunks show the effect: # byrow = FALSE (default) x &lt;- matrix(data = 1:9, ncol = 3, byrow = FALSE) # Print the object print(x) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # byrow = TRUE x &lt;- matrix(data = 1:9, ncol = 3, byrow = TRUE) # Print the object print(x) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 10.4 Column-binding and row-binding (vectors) Another way to create matrices in R is to row-bind or column-bind vectors. This is very useful if you do have a set of vectors and you want to combine or store them in one matrix object. Imagine we have two numeric vectors x and y of length 3 and we want to create a matrix which contains x in the first column and y in the second column. To do so, we can simply call the cbind function. # Two numeric vectors x &lt;- c(5, 5, 5) y &lt;- c(11, 22, 33) # column-binding z &lt;- cbind(x, y) class(z) ## [1] &quot;matrix&quot; print(z) ## x y ## [1,] 5 11 ## [2,] 5 22 ## [3,] 5 33 The result of cbind(x, y) is a \\(3 \\times 2\\) matrix. cbind can also be used to combine more than two vectors but note that not all combinations of lengths are allowed (well, R tries to recycle the vectors to match the length of the longest vector and will warn you if this is not possible. Try it out!). Column names: note that, in case of cbind and also rbind R automatically uses the names of the vectors (here x and y) as row or column name. We will learn how to access and specify row names and column names later in this document. The counterpart of cbind is rbind which works the very same, but combines the vectors row-wise and not column-wise. # Two numeric vectors x &lt;- c(5, 5, 5) y &lt;- c(11, 22, 33) # column-binding z &lt;- rbind(x, y) class(z) ## [1] &quot;matrix&quot; print(z) ## [,1] [,2] [,3] ## x 5 5 5 ## y 11 22 33 10.5 Column-binding and row-binding (matrices) cbind and rbind can also be used to combine matrices. Again, you have to take care of the dimensions of the matrices. However, let’s assume we have two matrices of the very same dimension (both, x1 and x2 are \\(3 \\times 2\\) matrices). Row-binding and column-binding of matrices works just the same as for vectors: # Two matrices x1 &lt;- matrix(1:6, ncol = 2) x2 &lt;- matrix(101:106, ncol = 2) # column-binding cbind(x1, x2) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 101 104 ## [2,] 2 5 102 105 ## [3,] 3 6 103 106 # Two matrices x1 &lt;- matrix(1:6, ncol = 2) x2 &lt;- matrix(101:106, ncol = 2) # column-binding rbind(x1, x2) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 ## [4,] 101 104 ## [5,] 102 105 ## [6,] 103 106 … except that no automatic row/column names are set. If x1 and/or x2 would have had row and/or column names they would have been kept, of course. 10.6 Matrix attributes As we now know how to create simple matrices let’s check the attributes. Remember: matrices are “just” vectors with additional attributes! While a vector only has a class and a certain length, matrices come with an additional dimension attribute. The function dim returns the dimension of the matrix, an integer vector of length \\(2\\) where the first element corresponds to the number of rows (always rows first), the second element corresponds to the number of column.s x &lt;- matrix(1:12, nrow = 4) x # Show matrix ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 dim(x) # Matrix dimension ## [1] 4 3 As we all know how ‘vector subsetting by index’ works we can now easily pick the number of rows and columns using: `dim(x)[1L]}: number of rows, `dim(x)[2L]}: number of columns. … or use nrow and ncol, two convenient functions to either get the number of rows or columns. nrow(x) # Number of rows ## [1] 4 ncol(x) # Number of columns ## [1] 3 length(x) # Length ## [1] 12 class(x) # Class ## [1] &quot;matrix&quot; is.matrix(x) # Check if is matrix ## [1] TRUE Note: a matrix also always has a length! This length corresponds to the underlying vector. A \\(3 \\times 3\\) matrix is of length 9 (has 9 elements), a \\(5 \\times 5\\) matrix is of length 25 and so far and so on. As for all objects we can retrieve the class of the object by calling the class function, and use is.matrix to check whether or not a certain object is of class matrix or not (returns TRUE or FALSE). 10.7 Setting dimension names (, ) Another important attribute of a matrix are the dimension names, or row names and column names (in case of two-dimensional matrices). They can be accessed and specified using the rownames and colnames functions. Let us create a \\(3 \\times 3\\) matrix … # Same matrix again x &lt;- matrix(data = 1:9, nrow = 3, ncol = 3) … and set row and column names using character vectors. As our matrix x has three rows and three columns, we do have to provide three row names and three column names. Note that the naming here is not very useful but demonstrates how they can be defined: rownames(x) &lt;- c(&quot;Row 1&quot;, &quot;Row 2&quot;, &quot;Row 3&quot;) colnames(x) &lt;- c(&quot;Col A&quot;, &quot;Col B&quot;, &quot;Col C&quot;) If we print the matrix x again we can see that all our rows and columns are now labeled. print(x) ## Col A Col B Col C ## Row 1 1 4 7 ## Row 2 2 5 8 ## Row 3 3 6 9 rownames and colnames cannot only be used to set the names but also to get the names from an existing object: rownames(x) ## [1] &quot;Row 1&quot; &quot;Row 2&quot; &quot;Row 3&quot; colnames(x) ## [1] &quot;Col A&quot; &quot;Col B&quot; &quot;Col C&quot; dim(x) ## [1] 3 3 Additional hint: we don’t always have to set all row names and column names, we could also only set or change one specific element by e.g., calling rownames(x)[1L] &lt;- &quot;Fooo&quot; to overwrite the rowname of the first row (1L) with &quot;Fooo&quot;. 10.8 Set dimension names when creating the object Another way is to directly specify the dimension names when calling the matrix function. The function takes up an optional input dimnames (by default this is set to NULL). We can specify a list containing two character vectors (dimnames = list(&lt;rownames&gt;, &lt;colnames&gt;)) where the first vector contains the row names, the second one the column names: # Create matrix with dimension names x &lt;- matrix(data = 1:9, ncol = 3, dimnames = list(c(&quot;Row 1&quot;, &quot;Row 2&quot;, &quot;Row 3&quot;), c(&quot;Col A&quot;, &quot;Col B&quot;, &quot;Col C&quot;))) # Print the object print(x) ## Col A Col B Col C ## Row 1 1 4 7 ## Row 2 2 5 8 ## Row 3 3 6 9 … to get the very same result as in the section above. 10.9 Practical Exercises (part 1) Note that there are no solutions in this file, there’s an extra file on OLAT with a detailed solution to the following short exercises. ### Practical exercise 1 Create the following matrices using matrix(...): ## [,1] [,2] ## [1,] NA NA ## [2,] NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 ## A B C ## row_1 1 2 3 ## row_2 1 2 3 ## row_3 1 2 3 ## row_4 1 2 3 ## row_5 1 2 3 Furthermore, check attributes, length, dimension. 10.9.1 Practical exercise 2 Create the following matrices based on three (logical/numeric) vectors (A/B/C;X1/X2/X3) and row and/or column bind: ## A B C ## [1,] TRUE FALSE FALSE ## [2,] TRUE TRUE FALSE ## [3,] TRUE TRUE TRUE ## [,1] [,2] [,3] ## A TRUE TRUE TRUE ## B FALSE TRUE TRUE ## C FALSE FALSE TRUE ## X1 X2 X3 ## [1,] 1.1 100 -500 ## [2,] 2.2 200 500 Furthermore, check attributes, length, dimension. 10.10 Subsetting matrices Subsetting matrices is similar to subsetting vectors except that we can subset by row and/or column. As for vectors we can: subsetting by index subsetting by name (if set) typically (not necessarily) two-dimensional! When using row and column indizes it is again rows first, columns second. The following image shows the indexing of a matrix. The blue numbers correspond to the row index (thus always 1 for the top row, 2 for the second row, …), the red numbers the index of the columns (1s left, 2 middle, …). Imagine we do have the following matrix: x # Demo matrix ## Col A Col B Col C ## Row 1 101 105 109 ## Row 2 102 106 110 ## Row 3 103 107 111 ## Row 4 104 108 112 Using subsetting by index we can now access specific elements by calling: x[3, 2] ## [1] 107 x[1, 3] ## [1] 109 The first call picks the element in the third row and second column, the second call the element in row 1 and column three. What happens if we use one single value instead of two (one for the rows, one for the columns) as above? x[10] # What happens here? ## [1] 110 Well, a matrix is built on a vector. x[10L] gives us the tenth element of the vector! As matrices are filled by column (!even if you specify byrow = TRUE; that just stores the data in a different order) the tenth element of our \\(4 times 3\\) matrix is x[3, 2]. You can number them (top down, starting top left). The first column contains the elements 1L, 2L, 3L, 4L, the second column the elements 5L to 8L, the third column starts with 9L followed by the one we are interested in, x[10L] (the element x[2, 3]). print(x) ## Col A Col B Col C ## Row 1 101 105 109 ## Row 2 102 106 110 ## Row 3 103 107 111 ## Row 4 104 108 112 Instead of picking single elements of the matrix we can also subset specific rows or columns. We can do this by leaving one index empty (empty means “all”). E.g. x[3, ] means “give me the third row, all columns”: # Subsetting 3th row x[3, ] ## Col A Col B Col C ## 103 107 111 class(x[3, ]) ## [1] &quot;numeric&quot; length(x[3, ]) ## [1] 3 dim(x[3, ]) # Is a vector! ## NULL Note that, by default, R returns us a vector if we subset one specific row or column! The result is no longer a matrix. The counterpart to row-subsetting is column-subsetting which works the very same way: # Subsetting 3th column x[, 3] ## Row 1 Row 2 Row 3 Row 4 ## 109 110 111 112 class(x[, 3]) ## [1] &quot;numeric&quot; length(x[, 3]) ## [1] 4 dim(x[, 3]) # Is a vector! ## NULL If you do algebra with R you may need a row or column vector: Column vector: matrix with only one column (an \\(N \\times 1\\) matrix) Row vector: matrix with only one row (an \\(1 \\times N\\) matrix) This can be achieved by setting the drop = FALSE argument. If drop = FALSE is set R does not drop the matrix attributes (i.e., row names, column names, dimension, class) and the result will be of class matrix: # Row vector x[3, , drop = FALSE] ## Col A Col B Col C ## Row 3 103 107 111 class(x[3, , drop = FALSE]) ## [1] &quot;matrix&quot; # Column vector x[, 3, drop = FALSE] ## Col C ## Row 1 109 ## Row 2 110 ## Row 3 111 ## Row 4 112 class(x[, 3, drop = FALSE]) ## [1] &quot;matrix&quot; We can, of course, also combine row and column subsetting. The following calls: extract the second and third row (c(2, 3)), but only the first column (1). extract the fourth row, but only the first and second column (c(1,2)). x # Our matrix ## Col A Col B Col C ## Row 1 101 105 109 ## Row 2 102 106 110 ## Row 3 103 107 111 ## Row 4 104 108 112 # 2nd and 3th row, 1th column x[c(2, 3), 1] ## Row 2 Row 3 ## 102 103 # 4th row, 1th and 2nd column x[4, c(1, 2)] ## Col A Col B ## 104 108 Again, if the result contains only one row or only one column R drops the matrix attributes and simplifies the result to a vector. To avoid that, we can set drop = FALSE again: # 2nd and 3th row, 1th column x[c(2, 3), 1, drop = FALSE] ## Col A ## Row 2 102 ## Row 3 103 # 4th row, 1th and 2nd column x[4, c(1, 2), drop = FALSE] ## Col A Col B ## Row 4 104 108 10.11 Subsetting matrices with logical vectors We can also subset matrices with logical vectors. This is used for subsetting with logics. When using logical vectors, these vectors have to match the dimensions (have the same length as the number of rows or columns). An example “doing it by hand”: Rows: c(FALSE, TRUE, FALSE, FALSE) (only 2_nd_ row) Columns: c(TRUE, FALSE, TRUE) (only 1_th_ &amp; 3_th_ column) Attributes: drop = FALSE (do not drop) # Our matrix x ## Col A Col B Col C ## Row 1 101 105 109 ## Row 2 102 106 110 ## Row 3 103 107 111 ## Row 4 104 108 112 # Subsetting x[c(FALSE, TRUE, FALSE, FALSE), c(TRUE, FALSE, TRUE), drop = FALSE] ## Col A Col C ## Row 2 102 110 10.12 Subsetting by name Very useful is subsetting by name. This is, again, similar to subsetting named vectors, except that we do have two dimensions here: # Only &quot;Col A&quot; x[, &quot;Col A&quot;] ## Row 1 Row 2 Row 3 Row 4 ## 101 102 103 104 # The element &quot;Row 3&quot;, &quot;Col B&quot; x[&quot;Row 3&quot;, &quot;Col B&quot;] ## [1] 107 # Or &quot;Col A&quot; * &quot;Col C&quot; z &lt;- x[, &quot;Col A&quot;] - x[, &quot;Col C&quot;] z ## Row 1 Row 2 Row 3 Row 4 ## -8 -8 -8 -8 class(z) ## [1] &quot;numeric&quot; names(z) ## [1] &quot;Row 1&quot; &quot;Row 2&quot; &quot;Row 3&quot; &quot;Row 4&quot; You may again use drop = FALSE. If not (drop = TRUE, the default) the result will be a named vector. 10.13 Non-existing elements in matrices From vectors we know that an NA will be returned if we access an element which does not exist, e.g., if we try to access element 10 (x[10L]) in a vector x which only contains 5 elements. x &lt;- c(1L, 2L, 3L) x[10] # non-existent, returns NA ## [1] NA For matrices, when using x[&lt;rowindex&gt;, &lt;colindex&gt;] the stroy is a bit different: we will run into an ERROR which looks as follows: x &lt;- matrix(1:9, nrow = 3) x[10,10] # non-existent, error! Error in x[10, 10] : subscript out of bounds Whenever you run into this error: check your indices/names/matrix dimension! 10.14 The subset method There is a generic method called subset. The method can also be used on vectors (but not very useful). However, when dealing with matrices the subset method becomes interesting, and will be even more important on data.frames. subset can be used to subset a matrix similar to the ways we have learned above, however, the usage is different and may be more convenient. According to the R documentation (see ?subset or help(&quot;subset&quot;)): ## S3 method for class &#39;matrix&#39; subset(x, subset, select, drop = FALSE, ...) x: object to be subsetted subset: logical expression, indicating rows to keep select: expression, indicating columns to keep drop: drop attributes (default for subset is FALSE) Note: that the default for drop is FALSE when calling subset(...)! Imagine we have a matrix x which looks as follows: x # Our matrix ## age size kids ## Tom 23 1.79 1 ## Lea 34 1.73 3 ## Reto 22 1.80 0 ## Emma 28 1.51 0 The row names correspond to the given name of a set of people, the column names to some attributes (age of the person, body size, and number of kids). We can easily use subset to extract all individuals smaller than 1.75 using the subset argument: subset(x, subset = x[, &quot;size&quot;] &lt; 1.75) ## age size kids ## Lea 34 1.73 3 ## Emma 28 1.51 0 Note: x[, &quot;size&quot;] &lt; 1.75 does column subsetting by name (takes the column &quot;size&quot;) and checks whether or not each element in x[, &quot;size&quot;] is smaller than 1.75. If so, a logical TRUE will be returned, FALSE else. Thus, x[, &quot;size&quot;] &lt; 1.75 is doing nothing else than creating a logical vector (try to execute this to see what’s returned by x[, &quot;size&quot;] &lt; 1.75)! We can, of course, also use a more complex logical statement, e.g., searching for all individuals smaller than 1.80 and not younger than 30 years old (&amp;, the logical and): subset(x, subset = x[, &quot;size&quot;] &lt; 1.80 &amp; x[, &quot;age&quot;] &lt; 30) ## age size kids ## Tom 23 1.79 1 ## Emma 28 1.51 0 So far we have only used the subset input argument which subsets on rows. The select argument can be used to subset columns. An example: subset(x, select = &quot;kids&quot;) ## kids ## Tom 1 ## Lea 3 ## Reto 0 ## Emma 0 This only returns us the kids column. x[, c(&quot;kids&quot;), drop = TRUE] ## Tom Lea Reto Emma ## 1 3 0 0 Or we combine subset and `select: subset(x, subset = x[, &quot;size&quot;] &lt; 1.80 &amp; x[, &quot;age&quot;] &lt; 30, select = c(&quot;size&quot;, &quot;kids&quot;)) ## size kids ## Tom 1.79 1 ## Emma 1.51 0 10.15 Matrix Arithmetic 10.15.1 Matrices and scalars Matrices in R are often used for arithmetics when solving mathematical problems. In principle, all basic arithmetic operations work element-wise as for vectors: x # Demo matrix ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 # Addition x + 2 ## [,1] [,2] ## [1,] 3 5 ## [2,] 4 6 # Multiplication x * 1.5 ## [,1] [,2] ## [1,] 1.5 4.5 ## [2,] 3.0 6.0 The same is true for all other operations (e.g., +, -, *, /, **, %%, sin(...), cos(...), …). 10.15.2 Matrices and vectors What happens if we e.g., multiply a matrix of dimension \\(2 \\times 2\\) with a vector of length \\(2\\)? x # Demo matrix ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 dim(x) ## [1] 2 2 y # Demo vector ## [1] 10 100 length(y) ## [1] 2 # Multiplication x * y ## [,1] [,2] ## [1,] 10 30 ## [2,] 200 400 Note:* R recycles the vector! The vector is shorter than the matrix (vector length 2, matrix length 4). Thus, R simply re-uses the vector two times! In detail, the following happens: R spans up a matrix y which matches x and looks as follows: matrix(y, ncol = 2, nrow = 2) ## [,1] [,2] ## [1,] 10 10 ## [2,] 100 100 Afterwards, x and this “y matrix” are multiplied. This does not result in an error or warning as the length of the matrix (4) is divisible by the length of the vector (2). 10.16 Further functions I don’t want to talk about matrix arithmetics in detail. However, R can do ‘all’ you need, e.g.,: t(x): transpose x diag(x): diagonal of x x \\%*\\% y: matrix multiplication solve(x): compute the inverse of x crossprod(x, y): cross product outer(x, y): outer product det(x): calculate determinant qr(x): QR decomposition … for those interested in linear algebra/math with R, you may have a look at: See ?matmult or help(&quot;matmult&quot;) for more details https://www.math.uh.edu/~jmorgan/Math6397/day13/LinearAlgebraR-Handout.pdf https://www.amazon.com/Hands-On-Matrix-Algebra-Using-Applications/dp/9814313696 or simply use the internet search engine of your choice to find more material. 10.17 Practical Exercises (part 2) Note that there are no solutions in this file, there’s an extra file on OLAT with a detailed solution to the following short exercises. 10.17.1 Practical exercise 3 Create the following matrix: ## Column A Column B ## Row 1 10 20 ## Row 2 10 20 ## Row 3 10 20 From the matrix above, create: ## Row 1 Row 2 Row 3 ## Column A 10 10 10 ## Column B 20 20 20 and: ## Column A Column B ## Row 1 5 40 ## Row 2 5 40 ## Row 3 5 40 10.17.2 Practical exercise 4 Create the following matrix (medals table, Olympic winter games 2018). ## Bronce Silver Gold ## Norway 11 14 14 ## Germany 7 10 14 ## Canada 10 8 11 ## USA 6 8 9 Compute the sum of medals per country (e.g., use a for loop) and add it to the matrix to get: ## Bronce Silver Gold Total ## Norway 11 14 14 39 ## Germany 7 10 14 31 ## Canada 10 8 11 29 ## USA 6 8 9 23 10.17.3 Practical exercise 5 Create the following matrix: set.seed(1234) x &lt;- matrix(sample(-20:20, size = 25), nrow = 5, ncol = 5) x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 7 -16 -15 3 20 ## [2,] -5 19 -6 13 -18 ## [3,] 1 -17 -7 4 11 ## [4,] 16 18 -1 0 15 ## [5,] -12 5 8 -13 -19 Create a nested for loop: first, loop over the rows second, loop over the columns Check if the element x[i, j] is negative. If so, multiply it with itself and store it on x[i, j]. 10.18 Typical Examples ## name gender eyecolor age height ## 1 Renate female green 33 1.55 ## 2 Kurt male brown 22 1.75 ## 3 Hermann male brown 18 1.71 ## region year15 year16 year17 year18 ## 1 West 1.24 1.18 1.39 1.30 ## 2 Boise 1.37 1.14 1.49 1.49 ## 3 Tampa 1.36 1.26 1.62 1.33 10.18.1 Convert matrix to data frame dimnames &lt;- list(NULL, c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) xmat &lt;- matrix(1:9, nrow = 3, dimnames = dimnames) xmat ## A B C ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Convert matrix to data.frame xdf &lt;- as.data.frame(xmat) xdf ## A B C ## 1 1 4 7 ## 2 2 5 8 ## 3 3 6 9 10.18.2 Convert data frame to matrix xdf &lt;- data.frame(name = c(&quot;Ben&quot;, &quot;Lea&quot;), age = c(34, 23), IQ = c(90, 95)) xdf ## name age IQ ## 1 Ben 34 90 ## 2 Lea 23 95 # Convert data.frame to matrix xmat &lt;- as.matrix(xdf) xmat ## name age IQ ## [1,] &quot;Ben&quot; &quot;34&quot; &quot;90&quot; ## [2,] &quot;Lea&quot; &quot;23&quot; &quot;95&quot; xdf2 &lt;- as.data.frame(xmat, stringsAsFactors = FALSE) xdf2 ## name age IQ ## 1 Ben 34 90 ## 2 Lea 23 95 mean(xdf2$age) ## Warning in mean.default(xdf2$age): argument is not numeric or logical: ## returning NA ## [1] NA class(xdf2$name) ## [1] &quot;character&quot; class(xdf2$age) ## [1] &quot;character&quot; xdf2 &lt;- as.data.frame(xmat) # stringsAsFactors = TRUE xdf2 ## name age IQ ## 1 Ben 34 90 ## 2 Lea 23 95 class(xdf2$name) ## [1] &quot;factor&quot; class(xdf2$age) ## [1] &quot;factor&quot; "],
["factors.html", "Chapter 11 Factors 11.1 Practical Exercises", " Chapter 11 Factors print(participants) ## [1] Students Students Experts Students Experts Students ## Levels: Students Experts length(participants) ## [1] 6 class(participants) ## [1] &quot;factor&quot; # As integer (level as integer) as.integer(participants) ## [1] 1 1 2 1 2 1 # As character (label as character vector) as.character(participants) ## [1] &quot;Students&quot; &quot;Students&quot; &quot;Experts&quot; &quot;Students&quot; &quot;Experts&quot; &quot;Students&quot; # Generate character vector group &lt;- c(&quot;Group B&quot;, &quot;Group A&quot;, &quot;Group A&quot;, &quot;Group B&quot;, &quot;Group B&quot;) class(group) ## [1] &quot;character&quot; # Convert to factor group_factor &lt;- as.factor(group) class(group_factor) ## [1] &quot;factor&quot; # Print print(group) ## [1] &quot;Group B&quot; &quot;Group A&quot; &quot;Group A&quot; &quot;Group B&quot; &quot;Group B&quot; print(group_factor) ## [1] Group B Group A Group A Group B Group B ## Levels: Group A Group B group_factor &lt;- factor(group, levels = c(&quot;Group B&quot;, &quot;Group A&quot;), labels = c(&quot;Group-B&quot;, &quot;Group-A&quot;)) print(group_factor) ## [1] Group-B Group-A Group-A Group-B Group-B ## Levels: Group-B Group-A # Create new character vector age &lt;- c(&quot;adult&quot;, &quot;infant&quot;, &quot;infant&quot;, &quot;teen&quot;, &quot;adult&quot;) # Convert into ordered factor age_factor &lt;- factor(age, levels = c(&quot;infant&quot;, &quot;teen&quot;, &quot;adult&quot;), ordered = TRUE) print(age_factor) ## [1] adult infant infant teen adult ## Levels: infant &lt; teen &lt; adult 11.1 Practical Exercises 11.1.1 Practical Exercises 1 month &lt;- sample(month.abb, 24, replace = TRUE) class(month) ## [1] &quot;character&quot; month ## [1] &quot;Aug&quot; &quot;Nov&quot; &quot;Apr&quot; &quot;Dec&quot; &quot;Mar&quot; &quot;Jul&quot; &quot;Sep&quot; &quot;Mar&quot; &quot;Jun&quot; &quot;Apr&quot; &quot;Aug&quot; ## [12] &quot;Oct&quot; &quot;Nov&quot; &quot;Feb&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jan&quot; &quot;Jun&quot; &quot;Aug&quot; &quot;Mar&quot; &quot;Jun&quot; &quot;Jan&quot; ## [23] &quot;Jan&quot; &quot;Sep&quot; 11.1.2 Practical Exercises 2 concentration &lt;- sample(c(&quot;low&quot;, &quot;mid&quot;, &quot;high&quot;), 24, replace = TRUE) concentration ## [1] &quot;mid&quot; &quot;low&quot; &quot;high&quot; &quot;high&quot; &quot;mid&quot; &quot;high&quot; &quot;mid&quot; &quot;high&quot; &quot;low&quot; &quot;high&quot; ## [11] &quot;mid&quot; &quot;low&quot; &quot;mid&quot; &quot;high&quot; &quot;mid&quot; &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;high&quot; &quot;mid&quot; ## [21] &quot;low&quot; &quot;mid&quot; &quot;high&quot; &quot;mid&quot; 11.1.3 Practical Exercises 3 # Sampling 200 random values between 0 and 100 concentration &lt;- runif(200, 0, 100) 11.1.4 Descriptive Data Analysis # Read the data set (this is a real rds file!) load(&quot;demodata_eyecolor.rda&quot;) # Loading the data set, data set # from the R dataset package. data(&quot;cars&quot;) cars$speed &lt;- round(cars$speed * 1.609344, 1) # miles/h to km/h cars$dist &lt;- round(cars$dist * 0.3048, 1) # feet to meters head(cars, n = 3) ## speed dist ## 1 6.4 0.6 ## 2 6.4 3.0 ## 3 11.3 1.2 tail(cars, n = 3) ## speed dist ## 48 38.6 28.3 ## 49 38.6 36.6 ## 50 40.2 25.9 class(cars) ## [1] &quot;data.frame&quot; dim(cars) ## [1] 50 2 ncol(cars) ## [1] 2 nrow(cars) ## [1] 50 names(cars) ## [1] &quot;speed&quot; &quot;dist&quot; # Structure of the object str(cars) ## &#39;data.frame&#39;: 50 obs. of 2 variables: ## $ speed: num 6.4 6.4 11.3 11.3 12.9 14.5 16.1 16.1 16.1 17.7 ... ## $ dist : num 0.6 3 1.2 6.7 4.9 3 5.5 7.9 10.4 5.2 ... mean(cars$dist) ## [1] 13.1 sd(cars$dist) ## [1] 7.854103 var(cars$dist) ## [1] 61.68694 min(cars$dist) ## [1] 0.6 max(cars$dist) ## [1] 36.6 range(cars$dist) ## [1] 0.6 36.6 # Median and 50% quantile median(cars$dist) ## [1] 11 # Object summary summary(cars$dist) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.6 7.9 11.0 13.1 17.1 36.6 # Manually specified quantiles quantile(cars$dist, probs = c(0, 0.25, 0.5, 0.75, 1.0)) ## 0% 25% 50% 75% 100% ## 0.6 7.9 11.0 17.1 36.6 dups &lt;- duplicated(cars$dist) head(dups) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE sum(dups) ## [1] 15 table(dups) ## dups ## FALSE TRUE ## 35 15 x &lt;- c(2, 1, 10, 10, 10, 4, 5) duplicated(x) ## [1] FALSE FALSE FALSE TRUE TRUE FALSE FALSE duplicated(x, fromLast = TRUE) ## [1] FALSE FALSE TRUE TRUE FALSE FALSE FALSE if (anyDuplicated(x)) print(&quot;yep, we have duplicated entries&quot;) ## [1] &quot;yep, we have duplicated entries&quot; uniq &lt;- unique(cars$dist) head(uniq) ## [1] 0.6 3.0 1.2 6.7 4.9 5.5 length(uniq) ## [1] 35 "],
["lists.html", "Chapter 12 Lists", " Chapter 12 Lists Documentation ends here, I need to write the last part another day! Sorry. x &lt;- list(&quot;Max&quot;, &quot;Muster&quot;, 34) print(x) ## [[1]] ## [1] &quot;Max&quot; ## ## [[2]] ## [1] &quot;Muster&quot; ## ## [[3]] ## [1] 34 # Class of the object class(x) ## [1] &quot;list&quot; # Length of the object length(x) ## [1] 3 # Names of the object names(x) # No names set ## NULL x &lt;- list(&quot;Max Muster&quot;, c(1L, 2L), matrix(1:6, ncol = 2)) print(x) ## [[1]] ## [1] &quot;Max Muster&quot; ## ## [[2]] ## [1] 1 2 ## ## [[3]] ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 # Class of the object class(x) ## [1] &quot;list&quot; # Length of the object length(x) ## [1] 3 # Names of the object names(x) # No names set ## NULL x &lt;- list(given_name = &quot;Max&quot;, family_name = &quot;Muster&quot;, age = 35) print(x) ## $given_name ## [1] &quot;Max&quot; ## ## $family_name ## [1] &quot;Muster&quot; ## ## $age ## [1] 35 names(x) ## [1] &quot;given_name&quot; &quot;family_name&quot; &quot;age&quot; x &lt;- list(char = &quot;Max Muster&quot;, mat = matrix(1:6, ncol = 2)) print(x) ## $char ## [1] &quot;Max Muster&quot; ## ## $mat ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 names(x) ## [1] &quot;char&quot; &quot;mat&quot; x &lt;- list(given_name = &quot;Max&quot;, family_name = &quot;Muster&quot;, age = 34, mat = matrix(1:9, ncol = 3)) x[1L] ## $given_name ## [1] &quot;Max&quot; class(x[1L]) ## [1] &quot;list&quot; x[[1L]] ## [1] &quot;Max&quot; class(x[[1L]]) ## [1] &quot;character&quot; x &lt;- list(given_name = &quot;Max&quot;, family_name = &quot;Muster&quot;, age = 34, mat = matrix(1:9, ncol = 3)) x[&quot;age&quot;] ## $age ## [1] 34 class(x[&quot;age&quot;]) ## [1] &quot;list&quot; x[[&quot;age&quot;]] ## [1] 34 class(x[[&quot;age&quot;]]) ## [1] &quot;numeric&quot; x &lt;- list(given_name = &quot;Max&quot;, family_name = &quot;Muster&quot;, age = 34, mat = matrix(1:9, ncol = 3)) x$given_name # equiv. to x[[&quot;given_name&quot;]] ## [1] &quot;Max&quot; x$family_name # equiv. to x[[&quot;family_name&quot;]] ## [1] &quot;Muster&quot; x$mat # equiv. to x[[&quot;mat&quot;]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x &lt;- c(1L, 2L, 3L) x[10] # non-existent, returns NA ## [1] NA x &lt;- list(given_name = &quot;Max&quot;, age = 34) x$something # non-existent, returns NULL ## NULL "],
["data-frames.html", "Chapter 13 Data frames 13.1 Convert Objects", " Chapter 13 Data frames x &lt;- data.frame(given_name = c(&quot;Reto&quot;, &quot;Lea&quot;, &quot;Max&quot;), # character family_name = c(&quot;Stauffer&quot;, &quot;Muster&quot;, &quot;Pain&quot;), # character age = c(28, 25, 22), # numeric vegetarian = c(FALSE, FALSE, TRUE), # logical stringsAsFactors = FALSE) # to be discussed # Let&#39;s print x print(x) ## given_name family_name age vegetarian ## 1 Reto Stauffer 28 FALSE ## 2 Lea Muster 25 FALSE ## 3 Max Pain 22 TRUE cbind(x, data.frame(foo = c(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;))) ## given_name family_name age vegetarian foo ## 1 Reto Stauffer 28 FALSE AAA ## 2 Lea Muster 25 FALSE BBB ## 3 Max Pain 22 TRUE CCC x$bar &lt;- c(9999, 8888, 7777) x ## given_name family_name age vegetarian bar ## 1 Reto Stauffer 28 FALSE 9999 ## 2 Lea Muster 25 FALSE 8888 ## 3 Max Pain 22 TRUE 7777 # 3th row x[3, ] ## given_name family_name age vegetarian bar ## 3 Max Pain 22 TRUE 7777 # 2nd column x[3, 2] ## [1] &quot;Pain&quot; # 2nd row, column &quot;age&quot; x[2, &quot;age&quot;] ## [1] 25 # 3th row x[3, ] ## given_name family_name age vegetarian bar ## 3 Max Pain 22 TRUE 7777 class(x[3, ]) ## [1] &quot;data.frame&quot; # 3th column x[, 3] ## [1] 28 25 22 class(x[, 3]) ## [1] &quot;numeric&quot; # Element in row 3, column 2 x[3, 2] ## [1] &quot;Pain&quot; class(x[3, 2]) ## [1] &quot;character&quot; # 2nd row, column &quot;age&quot; x[2, &quot;age&quot;] ## [1] 25 class(x[2, &quot;age&quot;]) ## [1] &quot;numeric&quot; x # Our data frame ## given_name family_name age vegetarian ## 1 Reto Stauffer 28 FALSE ## 2 Lea Muster 25 FALSE ## 3 Max Pain 22 TRUE subset(x, subset = age &lt;= 25, select = c(given_name, age)) ## given_name age ## 2 Lea 25 ## 3 Max 22 x$age ## [1] 28 25 22 class(x$name) ## [1] &quot;NULL&quot; class(x$age) ## [1] &quot;numeric&quot; class(x$vegetarian) ## [1] &quot;logical&quot; 13.1 Convert Objects # Convert matrix to vector x &lt;- matrix(1:9, ncol = 3) as.vector(x) ## [1] 1 2 3 4 5 6 7 8 9 # Convert data.frame to list x &lt;- data.frame(name = c(&quot;Ben&quot;, &quot;Lea&quot;, &quot;Max&quot;), age = c(11, 22, 33)) as.list(x) ## $name ## [1] Ben Lea Max ## Levels: Ben Lea Max ## ## $age ## [1] 11 22 33 # Create a list x &lt;- list(name = c(&quot;Lea&quot;, &quot;Ben&quot;, &quot;MAx&quot;), age = c(11, 22, 33), sex = c(&quot;female&quot;, &quot;male&quot;, &quot;male&quot;)) as.data.frame(x, stringsAsFactors = FALSE) ## name age sex ## 1 Lea 11 female ## 2 Ben 22 male ## 3 MAx 33 male # name has only length 1 x &lt;- list(name = c(&quot;Lea&quot;), age = c(11, 22, 33), sex = c(&quot;female&quot;, &quot;male&quot;, &quot;male&quot;)) as.data.frame(x, stringsAsFactors = FALSE) ## name age sex ## 1 Lea 11 female ## 2 Lea 22 male ## 3 Lea 33 male ## transportation distance expenses duration ## 1 Railjet 462 39.9 4.15 ## 2 Car 475 190.0 4.47 ## 3 Bike 508 0.0 27.00 "],
["sort-order.html", "Chapter 14 Sort &amp; Order 14.1 Sorting a vector 14.2 Order of a vector 14.3 Sort to get order, order to sort 14.4 Sort a matrix 14.5 Sorting a data.frame 14.6 Practical Exercise", " Chapter 14 Sort &amp; Order Today we will learn about two new functions: Sort &amp; Order. Sometimes it is required to sort an object (vector, matrix, data.frame, …). Not surprisingly the the functions are called sort &amp; order. Note that R base does not provide convenience functions to directly sort data.frames, however, additional packages like e.g., plyr or data.table have extra functions for it. Nevertheless, we can also use the base functions to sort our objects without the need to install and load additional packages. 14.1 Sorting a vector To bring the values in order we can use sort. From ?sort/help(&quot;sort&quot;): Sort (or order) a vector or factor (partially) into ascending or descending order. For ordering along more than one variable, e.g., for sorting data frames, see &#39;order&#39;. sort(x, decreasing = FALSE, na.last = NA, ...) As we can see the function sort takes 3+ input arguments. The first one (x) is our vector, the following two arguments are optional and allow to control how the vector will be sorted. If not specified, the defaults will be used (decreasing = FALSE and na.last = NA). We will see how these arguments change the way the vector is sorted later on. For demonstration purposes let us create a simple integer vector with random numbers: # Set randomization seed set.seed(555) # Sampling some random integers x &lt;- sample(1:100, 10) # Setting element 8 to NA x[8] &lt;- NA x ## [1] 88 16 93 4 29 68 32 NA 62 49 Note that I have set the eight element (x[8]) to NA (missing value) as we have to take care about missing values when using sort. First, let’s simply call sort(x) and store the result (the sorted vector) on a new object called xs (“x sorted”). # Sort x, store sorted vector on sx xs &lt;- sort(x) xs ## [1] 4 16 29 32 49 62 68 88 93 xs now contains the sorted version of x with the smallest on the first element, the second largest on the second element and so far and so on. But the length of xs is no longer 10 (length of x) but 9 (length of xs)! The optional argument na.last The reason is that sort, by default, uses na.last = NA. If na.last = NA missing values will simply be removed from the vector! In some situations we might need to keep the NA values, and this can be controlled by using the additional argument na.last. Available options: na.last = NA (default): NAs are removed na.last = TRUE: NAs will be added to the end of the sorted vector (“place NA as last elements”). na.last = FALSE: NAs will be added to the beginning of the sorted vector (“do not put NAs as last, but as first elements). sort(x, na.last = NA) # default ## [1] 4 16 29 32 49 62 68 88 93 sort(x, na.last = TRUE) ## [1] 4 16 29 32 49 62 68 88 93 NA sort(x, na.last = FALSE) ## [1] NA 4 16 29 32 49 62 68 88 93 As you can see NAs are once removed, once placed at the end of the sorted vector, and once at the beginning of the sorted vector. The optional argument decreasing The other additional input argument decreasing = TRUE controls whether the result is sorted in ascending (smallest to largest) or descending (largest to smallest) order. For those using SQL: this is equivalent to &quot;ORDER BYfield_nameASC&quot; and &quot;ORDER BYfield_nameDESC&quot;. # Sort x descending sort(x, decreasing = TRUE) ## [1] 93 88 68 62 49 32 29 16 4 14.2 Order of a vector While sort sorts our vector, order returns us the order (index) of the position of the elements in ascending/descending order. From the R documentation (?order/help(&quot;order&quot;)): &#39;order&#39; returns a permutation which rearranges its first argument into ascending or descending order, breaking ties by further arguments. &#39;sort.list&#39; is the same, using only one argument. See the examples for how to use these functions to sort data frames, etc. order(..., na.last = TRUE, decreasing = FALSE, method = c(&quot;auto&quot;, &quot;shell&quot;, &quot;radix&quot;)) Let us use the same vector x we used before, but call order instead of sort this time: x # Show x ## [1] 88 16 93 4 29 68 32 NA 62 49 which(is.na(x)) # Position of NA ## [1] 8 # Order of vector x order(x) ## [1] 4 2 5 7 10 9 6 1 3 8 The result is an integer vector of the same length as the vector x. By default, order returns an ascending order. Thus, the first element returned by order gives us the position of the smallest value in x, the second element the second smallest, and so far, and so on. Here, the first element of order(x) (order(x)[1L]) is 4 which simply tells us that **the smallest value in x is on x[4. Remember that we have one missing value in x at position 8 (x[8L])! In contrast to sort, order does not remove missing values by default but uses na.last = TRUE. Thus, we find the index x at the end of the index vector returned by order(x). However, if needed we can also control the na.last behaviour as for the sort function, except that the default is different: order(x, na.last = NA) ## [1] 4 2 5 7 10 9 6 1 3 order(x, na.last = TRUE) # default ## [1] 4 2 5 7 10 9 6 1 3 8 order(x, na.last = FALSE) ## [1] 8 4 2 5 7 10 9 6 1 3 Acending/decending works the same way, if we set decreasing = TRUE R will return the resverse order (index of the largest element first): # Sort x descending order(x, decreasing = TRUE) ## [1] 3 1 6 9 10 7 5 2 4 8 14.3 Sort to get order, order to sort 14.3.1 Sort to get order Sort and order do something similar but not the same. To get a better understanding let’s play arund a bit using the following vector x: set.seed(333) x &lt;- sample(1:100, 5) x ## [1] 14 41 55 66 39 sort(x) ## [1] 14 39 41 55 66 order(x) ## [1] 1 5 2 3 4 x is a integer vector of length 5 containing the values “14, 41, 55, 66, 39”. The question is: How could we use sort to get the order of the elements in x without calling order)? Well, let’s think about it for a second. sort returns us the sorted vector of x. Thus, we could first use sort(x) and store the result on a new object xs. We know that order returns us the position of the elements in the original vector x. All we have to do is to find out at which position in x the smallest element is, and the smallest element is the one stored on xs[1L]! xs[2L] contains the second smallest element, … Thus, we could do the following: Sort x by calling xs &lt;- sort(x) Create a new empty vector idx to store the position of the element xs[i] in x Create a for loop wich goes along all elements in xs (loop over 1:length(xs)) # Create new object &#39;xs&#39;, # sorted version of x xs &lt;- sort(x, na.last = TRUE) # Empty vector to store index idx &lt;- vector(&quot;integer&quot;, length(x)) # Loop over &#39;xs&#39;, find &#39;xs[i]&#39; in x for (i in seq_along(xs)) { idx[i] &lt;- which(x == xs[i]) } idx ## [1] 1 5 2 3 4 Et voila, we get the very same as when calling order (compare the result). Warning: will not work if x contains NAs. 14.3.2 Order to sort Another question is how to use order to sort a vector without calling sort! This is more straight forward and can be used to easily sort matrices and data frames. Let’s use the same vector x as before: set.seed(333) x &lt;- sample(1:100, 5) x ## [1] 14 41 55 66 39 sort(x) ## [1] 14 39 41 55 66 order(x) ## [1] 1 5 2 3 4 As we already know order returns us the index of the elements in x in an ascending order (by default). Let’s store the order(x) on a new object xorder. Thus, xorder[1L] contains the index of the smallest element in x, xorder[2L] the index of the second smallest element in x and so far and so on. All we have to do to bring x in an ascending order is to pick the elements of x with the index sequence of order. As xorder is an integer index vector we can simply call x[xorder]: # Get order of x xorder &lt;- order(x) # Pick elements in &#39;x&#39; in the # order of &#39;xorder&#39; x[xorder] ## [1] 14 39 41 55 66 … and done! x[order] (or, x[order(x)] if you prefer to write all in one go) returns us the very same result as sort(x). 14.4 Sort a matrix If we would like to sort a matrix we cannot simply use sort anymore. The reason: a matrix is basically a vector. Thus, sort(x) would return us ALL elements of the matrix x in an ascending/descending order (to be more specific: sort(x) of a matrix x returns a sorted vector). Thus, to be able to sort a matrix by a specific column, we have to do it slightly different. What we have to do is to: Create an order sequence (index of the rows of a specific column in the matrix). Rearrange the matrix x given the oder sequence from the first step. This will reorder/sort our matrix in a way that we will have an ascending/descending order of the data of a specific column of our matrix. But let’s do a practical example … Let us start with creating a relatively simple \\(3 \\times 3\\) integer matrix with with three columns called &quot;A&quot;, &quot;B&quot;, and &quot;C&quot; as follows: # Demo matrix x &lt;- matrix(c(10, 8, 8, 3, 8, 3, 1, 4, 20, 33, 11, 31), ncol = 3) colnames(x) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) x ## A B C ## [1,] 10 8 20 ## [2,] 8 3 33 ## [3,] 8 1 11 ## [4,] 3 4 31 Task 1: assume that we would like to have the matrix sorted such that we have ascending values in the first column (column &quot;A&quot;) without mixing up the data. For each row, the data should be the same as before, we only want to re-order the rows! To do so we can again use order on column &quot;A&quot; by calling order(x[, &quot;A&quot;]) (and store it on a new object idx). The result (idx) is an integer vector which tells us in which row we have the **smallest value in column &quot;A&quot;, and so far and so on. We can now use matrix subsetting by index on our rows to get the rows of x in the correct order. idx &lt;- order(x[, &quot;A&quot;]) idx ## [1] 4 2 3 1 # Re-order matrix (store on # &#39;xs&#39; (x sorted). xs &lt;- x[idx, ] xs ## A B C ## [1,] 3 4 31 ## [2,] 8 3 33 ## [3,] 8 1 11 ## [4,] 10 8 20 As you can see xs contains the sorted version with increasing values in column xs[, &quot;A&quot;], but the data in each row are kept the same (the first row of xs is simply what has been row 4 in our matrix x). We can do the very same but sort by column &quot;B&quot;: idx &lt;- order(x[, &quot;B&quot;]) idx ## [1] 3 2 4 1 # Re-order matrix (store on # &#39;xs&#39; (x sorted). xs &lt;- x[idx, ] xs ## A B C ## [1,] 8 1 11 ## [2,] 8 3 33 ## [3,] 3 4 31 ## [4,] 10 8 20 Sometimes it is required to not only sort by one specific column, but by first sort the matrix by one column, and then by another one. This can be done by calling order with more than one input vector. In this example I would like to sort the matrix x by column &quot;A&quot; first, and then (if needed) by column &quot;B&quot;. The procedure is the very same: we first create an index vector idx with the row indices and then re-order the matrix x and store it on xs: idx &lt;- order(x[, &quot;A&quot;], x[, &quot;B&quot;]) idx ## [1] 4 3 2 1 # Re-order xs &lt;- x[idx, ] xs ## A B C ## [1,] 3 4 31 ## [2,] 8 1 11 ## [3,] 8 3 33 ## [4,] 10 8 20 As you can see the result is different than before (check column &quot;B&quot;; second and third element). 14.5 Sorting a data.frame The very same as for a matrix can be used for a data.frame. In this example I am loading the faithful data set from the R dataset package. # Loading the old faithful # data set: data(&quot;faithful&quot;) head(faithful, n = 3) ## eruptions waiting ## 1 3.600 79 ## 2 1.800 54 ## 3 3.333 74 All I want to do is to sort the data.frame by eruption (eruption time in seconds) in an increasing or ascending order. First, we create a new index vector idx with the row indices … idx &lt;- order(faithful$eruption) head(idx) ## [1] 19 58 115 55 14 17 … which we can use to re-order our data.frame. As I don’t need the unsorted version of the object faithful anymore I simply overwrite it (faithful &lt;- faithful[idx,]): # Re-order (overwrite the # old object &#39;faithful&#39; here) faithful &lt;- faithful[idx, ] # Head of sorted object head(faithful) ## eruptions waiting ## 19 1.600 52 ## 58 1.667 64 ## 115 1.700 59 ## 55 1.733 54 ## 14 1.750 47 ## 17 1.750 62 As head(faithful, n = 6) returns us the first 6 entries of our data.frame this is a very convenient way to get the 6 elements with the smallest eruption times if needed (y &lt;- head(faithful)). 14.6 Practical Exercise The second practical example is about the good old titanic. You can find a file called &quot;titanic_with_age.rda&quot; on OLAT (Downloads/Files) which contains some information about the passengers of the RMS Titanic. Try to do the following step/answer the following questions: Investigate the loaded object(s). Write a for loop to get/print the class of each variable. Do we have missing values? Do we have wrong/suspicious values? For numeric columns: calculate summary statistics (e.g., mean, minimum, maximum, range, …). Sort the object by age (decreasing, oldest first). Create a new factor variable age_group with &quot;child&quot; for passengers \\(\\le 14\\) and &quot;adult&quot; for all others. Create a subset for “females”, one for “males” using subset. Use subset to create a new object only containing the variablesgenderandalive`. Was it more likely to survive as a female? Count number of males/females and (given gender) how may of them survived/died. Advanced: use table and prop.table "]
]
